This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: Assets/**/*.cs, Assets/**/*.shader, Assets/**/*.uss, Assets/**/*.uxml, Packages/**/*.cs
- Files matching these patterns are excluded: **/*.meta, Library/**, Temp/**, Logs/**, UserSettings/**, Builds/**, Obj/**, **/*.csproj, **/*.sln, **/*.mat, **/*.prefab, **/*.unity, **/*.asset, **/*.png, **/*.jpg, **/*.tga, **/*.fbx, .vs/**, .idea/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<user_provided_header>
Unity Project Source Code
</user_provided_header>

<directory_structure>
Assets/_Project/Scripts/AI/NpcController.cs
Assets/_Project/Scripts/Api/AuthApiService.cs
Assets/_Project/Scripts/Api/CannonballApiService.cs
Assets/_Project/Scripts/Api/PlayerApiService.cs
Assets/_Project/Scripts/CannonballProjectile.cs
Assets/_Project/Scripts/Core/BaseApiService.cs
Assets/_Project/Scripts/Core/BuildManager.cs
Assets/_Project/Scripts/Core/CameraManager.cs
Assets/_Project/Scripts/Core/GameDataService.cs
Assets/_Project/Scripts/Core/GameManager.cs
Assets/_Project/Scripts/Core/GameSession.cs
Assets/_Project/Scripts/Core/IGameService.cs
Assets/_Project/Scripts/Core/InGameDebugConsole.cs
Assets/_Project/Scripts/Core/NpcManager.cs
Assets/_Project/Scripts/Core/PlayerInventory.cs
Assets/_Project/Scripts/Core/PlayerManager.cs
Assets/_Project/Scripts/Core/RespawnCoordinator.cs
Assets/_Project/Scripts/Core/Server/ServerPlayerSession.cs
Assets/_Project/Scripts/Core/Server/ServerSessionManager.cs
Assets/_Project/Scripts/Core/ServiceLocator.cs
Assets/_Project/Scripts/Data/AuthResponse.cs
Assets/_Project/Scripts/Data/CannonballData.cs
Assets/_Project/Scripts/Data/CannonballDatabase.cs
Assets/_Project/Scripts/Data/LoginRequest.cs
Assets/_Project/Scripts/Data/NpcData.cs
Assets/_Project/Scripts/Data/ShipDetailResponse.cs
Assets/_Project/Scripts/Data/ShipStatsData.cs
Assets/_Project/Scripts/Health.cs
Assets/_Project/Scripts/NetworkManagerUI.cs
Assets/_Project/Scripts/PlayerController.cs
Assets/_Project/Scripts/PlayerInfo.cs
Assets/_Project/Scripts/ShipCombat.cs
Assets/_Project/Scripts/ShipIdentity.cs
Assets/_Project/Scripts/ShipStats.cs
Assets/_Project/Scripts/Targetable.cs
Assets/_Project/Scripts/UI/CannonballListItem.cs
Assets/_Project/Scripts/UI/CannonballUIController.cs
Assets/_Project/Scripts/UI/DeathUIController.cs
Assets/_Project/Scripts/UI/MainMenuUIManager.cs
Assets/_Project/Scripts/UI/PlayerHUDController.cs
Assets/_Project/Scripts/UI/ShipSelectionButton.cs
Assets/_Project/Scripts/UI/TargetingUIManager.cs
Assets/_Project/Scripts/UI/UIDragHandle.cs
Assets/_Project/Scripts/UI/WorldSpaceUIFollower.cs
Assets/_Project/Scripts/VFX/AutoDestroyParticle.cs
Assets/_Project/Settings/PlayerInputActions.cs
Assets/Hovl Studio/Procedural fire/Shaders/FireSphere.shader
Assets/TextMesh Pro/Shaders/TMP_Bitmap-Custom-Atlas.shader
Assets/TextMesh Pro/Shaders/TMP_Bitmap-Mobile.shader
Assets/TextMesh Pro/Shaders/TMP_Bitmap.shader
Assets/TextMesh Pro/Shaders/TMP_SDF Overlay.shader
Assets/TextMesh Pro/Shaders/TMP_SDF SSD.shader
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile Masking.shader
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile Overlay.shader
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile SSD.shader
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile-2-Pass.shader
Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile.shader
Assets/TextMesh Pro/Shaders/TMP_SDF-Surface-Mobile.shader
Assets/TextMesh Pro/Shaders/TMP_SDF-Surface.shader
Assets/TextMesh Pro/Shaders/TMP_SDF.shader
Assets/TextMesh Pro/Shaders/TMP_Sprite.shader
Assets/TutorialInfo/Scripts/Editor/ReadmeEditor.cs
Assets/TutorialInfo/Scripts/Readme.cs
Assets/TwoUncleVFX/Common/Script/BulletController.cs
Assets/TwoUncleVFX/Common/Script/BulletController2.cs
Assets/TwoUncleVFX/Common/Script/ChangeFX.cs
Assets/TwoUncleVFX/Common/Script/ChangeFX2.cs
Assets/TwoUncleVFX/Common/Script/ChangeFXParameter.cs
Assets/TwoUncleVFX/Common/Script/CheckMSAA.cs
Assets/TwoUncleVFX/Common/Script/LineManager.cs
Assets/TwoUncleVFX/Common/Script/RotateAround.cs
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="Assets/_Project/Scripts/Core/Server/ServerPlayerSession.cs">
using System;
using System.Collections.Generic;
using BarbarosKs.Shared.DTOs;

/// <summary>
/// Sunucuda RAM üzerinde yaşayan, oyuncunun anlık verilerini tutan sınıf.
/// NetworkVariable DEĞİLDİR. Mantıksal hesaplamalar burada yapılır.
/// </summary>
public class ServerPlayerSession
{
    public ulong ClientId { get; private set; } // Netcode client id
    public Guid CharacterId { get; private set; } // BD Ship Id
    public string PlayerName { get; private set; }

    // --- Değişken Oyun Verileri ---
    public int CurrentHealth { get; set; }
    public int MaxHealth { get; set; }

    public Dictionary<int, int> Inventory { get; private set; } = new Dictionary<int, int>();
    public bool IsDirty { get; set; } = false; // Veri değiştimi ? (API'ya gitmeli mi ?)
    public DateTime LastSaveTime { get; set; }

    public ServerPlayerSession(ulong clientId, Guid characterId, string playerName, int currentHealth, int maxHealth)
    {
        ClientId = clientId;
        CharacterId = characterId;
        PlayerName = playerName;
        CurrentHealth = currentHealth;
        MaxHealth = maxHealth;
    }

    public void SetInventory(List<ShipCannonballInventoryDto> invertoryDtos)
    {
        Inventory.Clear();
        foreach (var item in invertoryDtos)
        {
            Inventory[item.CannonballCode] = item.Quantity;
        }
    }

    /// <summary>
    /// Sunucuda RAM üzerinde yaşayan, oyuncunun anlık verilerini tutan sınıf.
    /// NetworkVariable DEĞİLDİR. Mantıksal hesaplamalar burada yapılır.
    /// </summary>
    public bool TryConsumeAmmo(int cannonballCode, int amount = 1)
    {
        if (Inventory.TryGetValue(cannonballCode, out var count) && count >= amount)
        {
            Inventory[cannonballCode] -= amount;
            IsDirty = true;
            return true;
        }

        return false;
    }

    /// <summary>
    /// Hasar al.
    /// </summary>
    public void ApplyDamage(int damage)
    {
        CurrentHealth = Math.Max(0, CurrentHealth - damage);
        IsDirty = true;
    }
}
</file>

<file path="Assets/_Project/Scripts/Core/Server/ServerSessionManager.cs">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using BarbarosKs.Shared.DTOs;
using Unity.Netcode;
using UnityEngine;

/// <summary>
/// Tüm oyuncuların RAM datalarını yöneten Singleton servis.
/// Sadece SUNUCU tarafında çalışır.
/// </summary>
public class ServerSessionManager : MonoBehaviour, IGameService
{
    // ClientId -> Session haritası (Hızlı erişim için)
    private readonly Dictionary<ulong, ServerPlayerSession> _activeSessions = new();

    //singleton erişimi (veya serviceLocator üzerinden)
    public static ServerSessionManager Instance { get; private set; }

    [Header("Settings")] [SerializeField] private float _autoSaveInternal = 5.0f;
    private float _timer;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject);
    }

    private void Update()
    {
        if (!NetworkManager.Singleton.IsServer) return;

        //Toplu güncelleme
        _timer += Time.deltaTime;
        if (_timer >= _autoSaveInternal)
        {
            _timer = 0;
            _ = SaveDirtySessionAsync(); // fire and forget
        }
    }

    /// <summary>
    /// Oyuncu oyuna girdiğinde (SpawnPlayer) çağrılır. Veriyi RAM'e yazar.
    /// </summary>
    public void RegisterSession(ulong clientId, Guid characterId, string name, int currentHp, int maxHp,
        List<ShipCannonballInventoryDto> inventory)
    {
        if (_activeSessions.ContainsKey(clientId))
        {
            Debug.LogWarning($"Client {clientId} için zaten bir session var, Üzerine yazılıyor");
            _activeSessions.Remove(clientId);
        }

        var session = new ServerPlayerSession(clientId, characterId, name, currentHp, maxHp);
        _activeSessions.Add(clientId, session);
        Debug.Log($"[ServerSessionManager] Session RAM'e eklendi: {name} (Client: {clientId})");
    }

    /// <summary>
    /// Oyuncu çıktığında RAM'den siler (önce son bir save yapılmalı).
    /// </summary>
    public void UnRegisterSession(ulong clientId)
    {
        if (_activeSessions.TryGetValue(clientId, out var session))
        {
            // Çıkmadan önce son durumu kaydetmeyi deneyebiliriz (Bloklamadan)
            // SaveSingleSession(session);
            _activeSessions.Remove(clientId);
            Debug.Log($"[ServerSessionManager] Session silindi: Client {clientId}");
        }
    }

    public ServerPlayerSession GetSession(ulong clientId)
    {
        _activeSessions.TryGetValue(clientId, out var session);
        return session;
    }

    /// <summary>
    /// Sadece verisi değişmiş (Dirty) oyuncuları bulup API'ye gönderir.
    /// </summary>
    private async Task SaveDirtySessionAsync()
    {
        // değişiklik olanları filtrele
        var dirtySessions = _activeSessions.Values.Where(s => s.IsDirty).ToList();
        if (dirtySessions.Count == 0) return;
        
        Debug.Log($"[BatchSave] {dirtySessions.Count} adet güncellenmiş oyuncu veriyi API'ye gönderiliyor...");
        
        // TODO: Burası için özel bir "BatchUpdateDto" oluşturacağız.
        // Şimdilik her biri için tek tek API çağırıyormuşuz gibi simüle edelim veya 
        // İleride tek bir POST isteği ile hepsini yollayacağız.
        
        // ÖNEMLİ: Dirty flag'ini hemen false yapıyoruz ki bir sonraki döngüde tekrar almayalım.
        // Eğer API hata verirse veri kaybı riski vardır (MMO trade-off: Performans vs Consistency).
        // Daha güvenli olması için API'den "OK" gelince false yapılabilir ama şimdilik hızlı olması için:
        foreach (var session in dirtySessions)
        {
            session.IsDirty = false; 
            session.LastSaveTime = DateTime.UtcNow;
        }

        // Simülasyon: API Service'e toplu DTO gönderimi burada yapılacak.
        // await ServiceLocator.Current.Get<PlayerApiService>().BatchUpdatePlayers(dtoList);
        await Task.CompletedTask;
    }
}
</file>

<file path="Assets/_Project/Scripts/AI/NpcController.cs">
// Filename: NpcController.cs

using System.Collections;
using System.Collections.Generic;
using Unity.Netcode;
using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(NavMeshAgent), typeof(ShipCombat), typeof(Targetable))]
public class NpcController : NetworkBehaviour
{
    [Header("NPC Referansları")]
    public Transform _cannonSpawnPoint;
    // --- Durumlar ---
    private enum State { Initializing, Patrolling, Chasing, Attacking }
    private State _currentState;
    
    // --- Referanslar ve Ayarlar ---
    private NavMeshAgent _navMeshAgent;
    private ShipCombat _shipCombat;
    private NpcData _npcData;
    private Transform _chaseTarget;
    private Vector3 _startPosition;
    
 
    public override void OnNetworkSpawn()
    {
        _navMeshAgent = GetComponent<NavMeshAgent>();

        if (!IsServer)
        {
            _navMeshAgent.enabled = false;
            this.enabled = false;
            return;
        }
        
        _shipCombat = GetComponent<ShipCombat>();
        
        // --- KRİTİK DEĞİŞİKLİK ---
        // Doğrudan bir duruma geçmek yerine, NavMesh'e yerleşme işlemini bir Coroutine ile başlat.
        StartCoroutine(InitializeAgentCoroutine());
    }

    public void Initialize(NpcData data)
    {
        _npcData = data;
    }
    
    /// <summary>
    /// Bu Coroutine, NavMesh sistemi hazır olana kadar bekler ve ardından ajanı yerleştirir.
    /// </summary>
    private IEnumerator InitializeAgentCoroutine()
    {
        // NavMesh'in yüklenmesi için birkaç kare bekle. Bu, zamanlama sorunlarını çözer.
        yield return new WaitForSeconds(1.0f); 

        // En yakın NavMesh noktasını bul ve oraya ışınlan (Warp).
        if (NavMesh.SamplePosition(transform.position, out NavMeshHit hit, 50.0f, NavMesh.AllAreas))
        {
            _navMeshAgent.Warp(hit.position);
            _startPosition = hit.position;
            _currentState = State.Patrolling;
            Debug.Log($"NPC {NetworkObjectId} başarıyla NavMesh'e yerleştirildi: {hit.position}");
        }
        else
        {
            Debug.LogError($"NPC {NetworkObjectId} için 50 birim yakında geçerli bir NavMesh yüzeyi BULUNAMADI! Sahnenin NavMesh'ini kontrol edin.");
            // İsteğe bağlı: NPC'yi yok et veya pasif bırak.
            // GetComponent<NetworkObject>().Despawn();
        }
    }


    private void Update()
    {
        // Sunucu değilse veya hala başlatılıyorsa, yapay zekayı çalıştırma.
        if (!IsServer || _currentState == State.Initializing) return;

        // State Machine (Durum Makinesi) mantığı
        switch (_currentState)
        {
            case State.Patrolling:
                LookForTargets();
                Patrol();
                break;
            case State.Chasing:
                ChaseTarget();
                break;
            case State.Attacking:
                AttackTarget();
                break;
        }
    }
    
    private void PlaceOnNavMesh()
    {
        // En yakın NavMesh noktasını bul ve oraya ışınlan (Warp).
        if (NavMesh.SamplePosition(transform.position, out NavMeshHit hit, 50.0f, NavMesh.AllAreas))
        {
            _navMeshAgent.Warp(hit.position);
            _startPosition = hit.position; // Başlangıç pozisyonunu güncelle.
            _currentState = State.Patrolling; // Başarılı, artık devriyeye başlayabiliriz.
            Debug.Log($"NPC {NetworkObjectId} başarıyla NavMesh'e yerleştirildi.");
        }
        else
        {
            // Eğer yakınlarda hiç NavMesh yoksa, bunu bir hata olarak bildir.
            Debug.LogError($"NPC {NetworkObjectId} için 50 birim yakında geçerli bir NavMesh yüzeyi bulunamadı!");
        }
    }

    private void LookForTargets()
    {
        // Belirli bir alandaki tüm collider'ları bul.
        Collider[] colliders = Physics.OverlapSphere(transform.position, _npcData.aggroRadius);
        foreach (var collider in colliders)
        {
            // Eğer bir oyuncu gemisi ise...
            if (collider.TryGetComponent<PlayerController>(out var player))
            {
                _chaseTarget = player.transform;
                _currentState = State.Chasing;
                return;
            }
        }
    }

    private void Patrol()
    {
        // Eğer bir hedefi yoksa veya hedefe vardıysa, yeni bir devriye noktası seç.
        if (!_navMeshAgent.hasPath || _navMeshAgent.remainingDistance < 1f)
        {
            Vector2 randomPoint = Random.insideUnitCircle * _npcData.patrolRadius;
            Vector3 destination = _startPosition + new Vector3(randomPoint.x, 0, randomPoint.y);
            _navMeshAgent.SetDestination(destination);
        }
    }

    private void ChaseTarget()
    {
        if (_chaseTarget == null)
        {
            _currentState = State.Patrolling;
            return;
        }

        float distance = Vector3.Distance(transform.position, _chaseTarget.position);
        
        // Eğer menzile girdiyse, saldırmaya başla.
        if (distance <= _npcData.range)
        {
            _currentState = State.Attacking;
            _shipCombat.ToggleAutoAttack(_chaseTarget.GetComponent<NetworkObject>().NetworkObjectId);
        }
        else // Menzilde değilse, takibe devam et.
        {
            _navMeshAgent.SetDestination(_chaseTarget.position);
        }
    }

    private void AttackTarget()
    {
        if (_chaseTarget == null)
        {
            _currentState = State.Patrolling;
            _shipCombat.ToggleAutoAttack(ulong.MaxValue); // Saldırıyı durdur
            return;
        }
        
        float distance = Vector3.Distance(transform.position, _chaseTarget.position);

        // Eğer hedef menzilden çıkarsa, tekrar takibe başla.
        if (distance > _npcData.range)
        {
            _currentState = State.Chasing;
            _shipCombat.ToggleAutoAttack(_chaseTarget.GetComponent<NetworkObject>().NetworkObjectId); // Saldırıyı durdur
        }
        else
        {
            // Hedefe doğru dönmeye devam et
            Vector3 direction = (_chaseTarget.position - transform.position).normalized;
            transform.rotation = Quaternion.Slerp(transform.rotation, Quaternion.LookRotation(direction), Time.deltaTime * 2f);
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/CannonballProjectile.cs">
// Filename: CannonballProjectile.cs

using Unity.Netcode;
using UnityEngine;

public class CannonballProjectile : NetworkBehaviour
{
    [Header("Effects")] public GameObject explosionPrefab; // Patlama efekti prefab'ı (Inspector'dan atanacak)

    private int _cannonballCode;
    private ulong _targetId;
    private int _damage;
    private float _speed;
    private Transform _targetTransform;


    public void Initialize(ulong targetId, int damage, float speed, int cannonballCode)
    {
        _targetId = targetId;
        _damage = damage;
        _speed = speed;
        _cannonballCode = cannonballCode;

        if (NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(_targetId, out NetworkObject targetObject))
        {
            _targetTransform = targetObject.transform;
        }
    }

    private void Update()
    {
        // Sadece sunucuda hareket et. NetworkTransform bu hareketi client'lara senkronize eder.
        if (!IsServer) return;

        // Eğer hedefimiz yok olduysa veya bir sebepten bulunamıyorsa, mermiyi yok et.
        if (_targetTransform == null)
        {
            GetComponent<NetworkObject>().Despawn(); // Hedef yoksa direkt yok ol.
            return;
        }

        // Hedefe doğru hareket et.
        Vector3 direction = (_targetTransform.position - transform.position).normalized;
        transform.position += direction * _speed * Time.deltaTime;
    }

    private void OnTriggerEnter(Collider other)
    {
        if (!IsServer) return;

        // Çarptığımız objenin NetworkObject'ini al ve ID'sini bizim hedefimizin ID'si ile karşılaştır.
        if (other.TryGetComponent<NetworkObject>(out var networkObject) && networkObject.NetworkObjectId == _targetId)
        {
            // Eğer doğru hedefe çarptıysak, hasar ver ve kendini yok et.
            DoImpact(other.transform);
        }
    }

    private void DoImpact(Transform impactTarget)
    {
        // Hedefin Health bileşenini bul ve hasar ver.
        if (impactTarget.TryGetComponent<Health>(out Health targetHealth))
        {
            targetHealth.TakeDamage(_damage);
        }

        // DÜZELTME: Patlama efektini oynatmak için tüm client'lara komut gönder.
        PlayImpactEffectsClientRpc(transform.position);

        // Mermiyi yok et.
        GetComponent<NetworkObject>().Despawn();
    }


    // Bu metot sunucu tarafından çağrılır, ancak tüm client'larda çalışır.
    [ClientRpc]
    private void PlayImpactEffectsClientRpc(Vector3 position)
    {
        var cannonballDb = GameManager.Instance.CannonballDatabase;
        CannonballData cannonballData = cannonballDb.GetCannonballByCode(_cannonballCode);
        if (cannonballData == null || cannonballData.impactEffectPrefab == null) return;

        Instantiate(cannonballData.impactEffectPrefab, position, Quaternion.identity);
    }
}
</file>

<file path="Assets/_Project/Scripts/Core/BuildManager.cs">
using System;
using UnityEngine;
#if UNITY_SERVER
using Unity.Netcode;
#endif

public class BuildManager : MonoBehaviour
{
    [Header("Client-Only Objects")]
    [Tooltip("Bu objeler, Dedicated Server build'inde otomatik olarak devre dışı bırakılacak")]
    [SerializeField]
    private GameObject[] _clientOnlyObjects;

    private void Start()
    {
#if UNITY_SERVER
        Debug.Log("--- DEDICATED SERVER BUILD ---");

        foreach (var obj in _clientOnlyObjects)
        {
            if (obj != null)
            {
                obj.SetActive(false);
            }
        }
        Debug.Log("--- DEDICATED SERVER STARTING ---");
        NetworkManager.Singleton.StartServer();
#else
        Debug.Log("--- CLIENT BUILD ---");
        // Client build'i, bağlanmak için UI butonlarını kullanacak.
#endif
    }
}
</file>

<file path="Assets/_Project/Scripts/Core/CameraManager.cs">
// Filename: CameraManager.cs (ULTRA-SAFE FINAL VERSION)
using Unity.Cinemachine;
using UnityEngine;

[RequireComponent(typeof(CinemachineCamera))]
public class CameraManager : MonoBehaviour
{
    private CinemachineCamera _cinemachineCamera;

    private void Awake()
    {
        _cinemachineCamera = GetComponent<CinemachineCamera>();
        PlayerController.OnLocalPlayerShipReady += InitializeCamera;
    }

    private void OnDestroy()
    {
        PlayerController.OnLocalPlayerShipReady -= InitializeCamera;
    }

    /// <summary>
    /// Bu metot artık SADECE kameranın ana hedeflerini atar.
    /// </summary>
    private void InitializeCamera(Transform playerShipTransform)
    {
        if (playerShipTransform == null) return;
        
        Debug.Log($"Kamera Follow ve LookAt hedefleri atanıyor: {playerShipTransform.name}");

        // KODUN TEK GÖREVİ BUDUR:
        _cinemachineCamera.Follow = playerShipTransform;
        _cinemachineCamera.LookAt = playerShipTransform;

        Debug.LogWarning("Kamera hedefleri atandı. Damping ve Offset gibi diğer tüm ayarları Inspector üzerinden manuel olarak yapınız.");
    }
}
</file>

<file path="Assets/_Project/Scripts/Core/GameSession.cs">
// Filename: GameSession.cs
using System;
using BarbarosKs.Shared.DTOs;

public class GameSession : IGameService
{
    public Guid SelectedShipId { get; set; }
    public string PlayerName { get; set; }
    public ShipDetailDto SelectedShip { get; set; }
}
</file>

<file path="Assets/_Project/Scripts/Core/IGameService.cs">
// Filename: IGameService.cs
public interface IGameService
{
    // Bu arayüz, bir sınıfın oyunumuzda bir "servis" olduğunu belirtmek için kullanılır.
    // Şimdilik herhangi bir metot veya özellik içermesine gerek yok.
}
</file>

<file path="Assets/_Project/Scripts/Core/InGameDebugConsole.cs">
// Filename: InGameDebugConsole.cs
using UnityEngine;
using System.Collections.Generic;

public class InGameDebugConsole : MonoBehaviour
{
    private struct Log
    {
        public string message;
        public string stackTrace;
        public LogType type;
    }

    private readonly List<Log> _logs = new List<Log>();
    private Vector2 _scrollPosition;
    private bool _show = true;
    private bool _collapse;

    private static readonly Dictionary<LogType, Color> _logTypeColors = new Dictionary<LogType, Color>
    {
        { LogType.Assert, Color.white },
        { LogType.Error, Color.red },
        { LogType.Exception, Color.red },
        { LogType.Log, Color.white },
        { LogType.Warning, Color.yellow },
    };

    private const int _maxLogs = 100;
    private const string _windowTitle = "In-Game Console";
    private readonly GUIContent _clearLabel = new GUIContent("Clear", "Clear the contents of the console.");
    private readonly GUIContent _collapseLabel = new GUIContent("Collapse", "Hide repeated messages.");

    private readonly Rect _titleBarRect = new Rect(0, 0, 10000, 20);
    private Rect _windowRect = new Rect(20, 20, Screen.width - 40, Screen.height - 40);

    private void OnEnable()
    {
        Application.logMessageReceived += HandleLog;
    }

    private void OnDisable()
    {
        Application.logMessageReceived -= HandleLog;
    }

    private void OnGUI()
    {
        if (!_show)
        {
            return;
        }

        _windowRect = GUILayout.Window(123456, _windowRect, DrawConsoleWindow, _windowTitle);
    }

    private void DrawConsoleWindow(int windowID)
    {
        _scrollPosition = GUILayout.BeginScrollView(_scrollPosition);

        for (int i = 0; i < _logs.Count; i++)
        {
            var log = _logs[i];
            GUI.contentColor = _logTypeColors[log.type];
            GUILayout.Label(log.message);
        }

        GUILayout.EndScrollView();
        GUI.contentColor = Color.white;

        GUILayout.BeginHorizontal();

        if (GUILayout.Button(_clearLabel))
        {
            _logs.Clear();
        }

        _collapse = GUILayout.Toggle(_collapse, _collapseLabel, GUILayout.ExpandWidth(false));

        GUILayout.EndHorizontal();
        GUI.DragWindow(_titleBarRect);
    }

    private void HandleLog(string message, string stackTrace, LogType type)
    {
        _logs.Add(new Log
        {
            message = message,
            stackTrace = stackTrace,
            type = type,
        });

        while (_logs.Count > _maxLogs)
        {
            _logs.RemoveAt(0);
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/Core/NpcManager.cs">
// Filename: NpcManager.cs (Simplified Version)
using UnityEngine;
using Unity.Netcode;

public class NpcManager : IGameService
{
    private NpcData _testNpcData;

    public void Initialize(NpcData testNpcData)
    {
        _testNpcData = testNpcData;
    }

    public void SpawnTestNpcs()
    {
        if (!NetworkManager.Singleton.IsServer) return;

        Debug.Log("Test NPC'leri spawn ediliyor...");
        // NPC'yi NavMesh'i düşünmeden, doğrudan hedef koordinatta yaratıyoruz.
        Vector3 spawnPosition = new Vector3(10, 0, 10); 

        GameObject npcInstance = Object.Instantiate(_testNpcData.shipPrefab, spawnPosition, Quaternion.identity);
        
        // Network'te spawn et.
        npcInstance.GetComponent<NetworkObject>().Spawn();
        
        // Gerekli bileşenleri doldur.
        var npcController = npcInstance.GetComponent<NpcController>();
        var shipCombat = npcInstance.GetComponent<ShipCombat>();
        
        npcController.Initialize(_testNpcData);
        npcInstance.GetComponent<Health>().Initialize(_testNpcData.maxHull, _testNpcData.maxHull);
        shipCombat.InitializeForNpc(_testNpcData.equippedCannonballCode, npcController._cannonSpawnPoint);
    }
}
</file>

<file path="Assets/_Project/Scripts/Core/PlayerInventory.cs">
// Filename: PlayerInventory.cs (Client-Side Inventory Cache)
using System.Collections.Generic;
using BarbarosKs.Shared.DTOs; // DLL'inizdeki DTO'ları kullanın
using UnityEngine;

public class PlayerInventory : IGameService
{
    // Hangi gülle kodundan kaç tane var?
    private readonly Dictionary<int, int> _cannonballQuantities = new Dictionary<int, int>();
    public IReadOnlyDictionary<int, int> CannonballQuantities => _cannonballQuantities;

    // API'den gelen envanter listesiyle bu servisi doldururuz.
    public void UpdateInventory(List<ShipCannonballInventoryDto> inventoryItems)
    {
        _cannonballQuantities.Clear();
        foreach (var item in inventoryItems)
        {
            _cannonballQuantities[item.CannonballCode] = item.Quantity; // CannonballTypeId code ile değiştir.
        }
        Debug.Log("Client gülle envanteri güncellendi.");
    }
    
    // Bu metotları client-taraflı UI güncellemeleri için kullanabiliriz.
    public int GetQuantity(int code) => _cannonballQuantities.TryGetValue(code, out int quantity) ? quantity : 0;
    
    public void SetQuantity(int code, int quantity)
    {
        if (_cannonballQuantities.ContainsKey(code))
        {
            _cannonballQuantities[code] = quantity;
        }
        else
        {
            _cannonballQuantities.Add(code, quantity);
        }
    
        // UI'ın güncellenmesi için bir event tetiklemek iyi olurdu ama
        // şimdilik CannonballUIController her açılışta yeniliyor.
        // Eğer anlık UI (HUD'da gülle sayısı) varsa, burada event fırlatmalısın.
    }
}
</file>

<file path="Assets/_Project/Scripts/Core/RespawnCoordinator.cs">
// Filename: RespawnCoordinator.cs

using System;
using System.Threading.Tasks;
using BarbarosKs.Shared.DTOs;
using Unity.Netcode;
using UnityEngine;

public class RespawnCoordinator : NetworkBehaviour
{
	[ServerRpc(RequireOwnership = false)]
	public void RequestRespawnAtDockyardServerRpc(ulong requesterClientId, string shipId)
	{
		if (!IsServer) return;
		Debug.Log($"[Respawn] İstek alındı. Client={requesterClientId} ShipId={shipId}");
		HandleRespawnRequestAsync(requesterClientId, shipId);
	}

	private async void HandleRespawnRequestAsync(ulong requesterClientId, string shipId)
	{
		ShipRespawnResultDto result = null;
		try
		{
			var playerApi = ServiceLocator.Current.Get<PlayerApiService>();
			result = await playerApi.RespawnShipAsync(Guid.Parse(shipId));
		}
		catch (Exception ex)
		{
			Debug.LogError($"[Respawn] Backend respawn çağrısında hata: {ex.Message}");
		}

		if (result == null)
		{
			Debug.LogError("[Respawn] Backend null döndü veya başarısız.");
			NotifyHidePanelClientRpc(new ClientRpcParams
			{
				Send = new ClientRpcSendParams { TargetClientIds = new[] { requesterClientId } }
			});
			return;
		}

		// Backend güncelledi: şimdi yeni gemiyi spawn edelim
		var playerManager = ServiceLocator.Current.Get<PlayerManager>();
		playerManager.SpawnPlayer(requesterClientId, result.ShipId);

		NotifyHidePanelClientRpc(new ClientRpcParams
		{
			Send = new ClientRpcSendParams { TargetClientIds = new[] { requesterClientId } }
		});
	}

	[ClientRpc]
	private void NotifyHidePanelClientRpc(ClientRpcParams clientRpcParams = default)
	{
		var deathUi = FindObjectOfType<DeathUIController>();
		if (deathUi != null)
		{
			deathUi.HidePanel();
		}
	}
}
</file>

<file path="Assets/_Project/Scripts/Core/ServiceLocator.cs">
// Filename: ServiceLocator.cs
using System;
using System.Collections.Generic;
using UnityEngine;

public class ServiceLocator
{
    // Singleton deseni ile ServiceLocator'a global erişim sağlıyoruz.
    public static ServiceLocator Current { get; private set; }

    // Servisleri tiplerine göre saklayacağımız bir sözlük (dictionary).
    private readonly Dictionary<Type, IGameService> _services = new Dictionary<Type, IGameService>();

    public ServiceLocator()
    {
        if (Current != null)
        {
            // Zaten bir ServiceLocator varsa, yeni bir tane oluşturulmasını engelle.
            Debug.LogError("Bir ServiceLocator örneği zaten mevcut.");
            return;
        }
        Current = this;
    }

    /// <summary>
    /// Bir servisi kaydeder.
    /// </summary>
    /// <typeparam name="T">Servisin tipi.</typeparam>
    /// <param name="service">Kaydedilecek servis örneği.</param>
    public void Register<T>(T service) where T : IGameService
    {
        var type = typeof(T);
        if (_services.TryAdd(type, service)) return;
        Debug.LogWarning($"Servis tipi {type.Name} zaten kayıtlı. Üzerine yazılıyor.");
        _services[type] = service;
    }

    /// <summary>
    /// Kayıtlı bir servisi getirir.
    /// </summary>
    /// <typeparam name="T">Getirilecek servisin tipi.</typeparam>
    /// <returns>İstenen servis örneği.</returns>
    public T Get<T>() where T : IGameService
    {
        var type = typeof(T);
        if (!_services.TryGetValue(type, out var service))
        {
            Debug.LogError($"Servis tipi {type.Name} bulunamadı.");
            throw new InvalidOperationException($"Servis bulunamadı: {type.Name}");
        }
        return (T)service;
    }
}
</file>

<file path="Assets/_Project/Scripts/Data/AuthResponse.cs">
// Filename: AuthResponse.cs
[System.Serializable]
public class AuthResponse
{
    public bool success;
    public string message;
    public string token;
    // playerData gibi diğer alanları şimdilik eklememize gerek yok.
}
</file>

<file path="Assets/_Project/Scripts/Data/CannonballData.cs">
// Filename: CannonballData.cs (Final, Clean Template)
using UnityEngine;

[CreateAssetMenu(fileName = "Cannonball_120001", menuName = "BarbarosKs/Cannonball Template")]
public class CannonballData : ScriptableObject
{
    [Header("Kimlik (API ile Eşleştirme)")]
    public int cannonballCode; // API'deki 'Code' alanı ile eşleşecek

    [Header("Görsel Varlıklar (Sadece Unity'de)")]
    public Sprite icon;
    public GameObject projectilePrefab;
    public GameObject muzzleFlashPrefab;
    public GameObject impactEffectPrefab;
}
</file>

<file path="Assets/_Project/Scripts/Data/CannonballDatabase.cs">
// Filename: CannonballDatabase.cs
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[CreateAssetMenu(fileName = "CannonballDatabase", menuName = "BarbarosKs/Cannonball Database")]
public class CannonballDatabase : ScriptableObject
{
    public List<CannonballData> allCannonballTemplates;

    public CannonballData GetCannonballByCode(int code)
    {
        return allCannonballTemplates.FirstOrDefault(c => c.cannonballCode == code);
    }
}
</file>

<file path="Assets/_Project/Scripts/Data/LoginRequest.cs">
// Filename: LoginRequest.cs
[System.Serializable]
public class LoginRequest
{
    public string email;
    public string password;
}
</file>

<file path="Assets/_Project/Scripts/Data/NpcData.cs">
// Filename: NpcData.cs
using UnityEngine;

[CreateAssetMenu(fileName = "NewNpcData", menuName = "BarbarosKs/NPC Data")]
public class NpcData : ScriptableObject
{
    [Header("Kimlik")]
    public string npcName = "Korsan";
    public GameObject shipPrefab; // Bu NPC'nin kullanacağı gemi prefab'ı

    [Header("Temel İstatistikler")]
    public int maxHull = 150;
    public float speed = 2f;
    public float maneuverability = 300f;
    public float attackRate = 5f;
    public float range = 25f;
    public int equippedCannonballCode = 120002; // Hangi gülleyle ateş edeceği (Demir Gülle)

    [Header("Yapay Zeka Davranışları")]
    public float aggroRadius = 30f; // Oyuncuyu ne kadar mesafeden fark edeceği
    public float patrolRadius = 50f; // Doğduğu noktanın ne kadar uzağında devriye gezeceği
}
</file>

<file path="Assets/_Project/Scripts/NetworkManagerUI.cs">
using Unity.Netcode;
using UnityEngine;
using UnityEngine.UI;

namespace _Project.Scripts
{
    public class NetworkManagerUI : MonoBehaviour
    {
        [SerializeField] private Button _hostButton;
        [SerializeField] private Button _clientButton;

        private void Awake()
        {
            _hostButton.onClick.AddListener(() =>
            {
                Debug.Log("Host Button Clicked");
                NetworkManager.Singleton.StartHost();
                HideButtons();
            });
            
            _clientButton.onClick.AddListener(() =>
            {
                Debug.Log("Client olarak bağlanılıyor");
                NetworkManager.Singleton.StartClient();
                HideButtons();
            });
        }

        private void HideButtons()
        {
            _hostButton.gameObject.SetActive(false);
            _clientButton.gameObject.SetActive(false);
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/ShipIdentity.cs">
using Unity.Netcode;
using Unity.Collections;
using UnityEngine.Serialization; // FixedString için
public class ShipIdentity : NetworkBehaviour
{
    // Network üzerinden senkronize olacak geminin benzersiz veritabanı ID'si.
    // Guid doğrudan senkronize edilemediği için string formatında (FixedString) tutuyoruz.
    [FormerlySerializedAs("ShipId")] public NetworkVariable<FixedString128Bytes> shipId = new NetworkVariable<FixedString128Bytes>();
}
</file>

<file path="Assets/_Project/Scripts/Targetable.cs">
// Filename: Targetable.cs
using UnityEngine;

public class Targetable : MonoBehaviour
{
    // Bu bileşen, bir nesnenin hedeflenebilir olduğunu işaretlemek için kullanılır.
    // Gelecekte buraya can, isim gibi bilgiler eklenebilir.
}
</file>

<file path="Assets/_Project/Scripts/UI/DeathUIController.cs">
// Filename: DeathUIController.cs

using UnityEngine;
using UnityEngine.UI;
using Unity.Netcode;

public class DeathUIController : MonoBehaviour
{
	[Header("Death UI References")]
	[SerializeField] private GameObject _deathPanel;
	[SerializeField] private Button _respawnButton;
	[Tooltip("Panelin görüneceği sağlık eşik değeri. Örn: 0 => sağlık 0 veya altına düşünce göster.")]
	[SerializeField] private int _healthThresholdToShow = 0;

	private Health _localPlayerHealth;

	private void Awake()
	{
		if (_deathPanel != null)
		{
			_deathPanel.SetActive(false);
		}
		if (_respawnButton != null)
		{
			_respawnButton.onClick.AddListener(OnRespawnClicked);
		}

		PlayerController.OnLocalPlayerShipReady += OnLocalPlayerShipReady;
	}

	private void OnDestroy()
	{
		PlayerController.OnLocalPlayerShipReady -= OnLocalPlayerShipReady;
		if (_localPlayerHealth != null)
		{
			_localPlayerHealth.CurrentHealth.OnValueChanged -= OnCurrentHealthChanged;
		}
		if (_respawnButton != null)
		{
			_respawnButton.onClick.RemoveListener(OnRespawnClicked);
		}
	}

	private void OnLocalPlayerShipReady(Transform playerTransform)
	{
		// Önce önceki abonelikten ayrıl
		if (_localPlayerHealth != null)
		{
			_localPlayerHealth.CurrentHealth.OnValueChanged -= OnCurrentHealthChanged;
		}

		_localPlayerHealth = playerTransform.GetComponent<Health>();
		if (_localPlayerHealth == null) return;
		_localPlayerHealth.CurrentHealth.OnValueChanged += OnCurrentHealthChanged;

		// Yeni gemi geldiğinde mevcut sağlık durumuna göre paneli güncelle
		UpdatePanelVisibilityForCurrentHealth(_localPlayerHealth.CurrentHealth.Value);
		// Ağ başlatma sırası nedeniyle bir frame sonra tekrar kontrol et (olasılık düşük ama güvenli)
		StartCoroutine(DeferredInitialCheck());
	}

	private void OnCurrentHealthChanged(int previousValue, int newValue)
	{
		UpdatePanelVisibilityForCurrentHealth(newValue);
	}

	private System.Collections.IEnumerator DeferredInitialCheck()
	{
		yield return null; // bir frame bekle
		if (_localPlayerHealth != null)
		{
			UpdatePanelVisibilityForCurrentHealth(_localPlayerHealth.CurrentHealth.Value);
		}
	}

	private void UpdatePanelVisibilityForCurrentHealth(int current)
	{
		if (current <= _healthThresholdToShow)
		{
			ShowPanel();
		}
		else
		{
			HidePanel();
		}
	}

	private void OnRespawnClicked()
	{
		if (_respawnButton != null) _respawnButton.interactable = false;

		var coordinator = FindObjectOfType<RespawnCoordinator>();
		if (coordinator == null)
		{
			Debug.LogError("RespawnCoordinator sahnede bulunamadı.");
			if (_respawnButton != null) _respawnButton.interactable = true;
			return;
		}

		var session = ServiceLocator.Current.Get<GameSession>();
		var shipId = session.SelectedShipId;
		coordinator.RequestRespawnAtDockyardServerRpc(NetworkManager.Singleton.LocalClientId, shipId.ToString());
	}

	public void ShowPanel()
	{
		if (_deathPanel)
		{
			_deathPanel.SetActive(true);
		}
	}

	public void HidePanel()
	{
		if (_deathPanel != null)
		{
			_deathPanel.SetActive(false);
		}
		if (_respawnButton != null)
		{
			_respawnButton.interactable = true;
		}
	}
}
</file>

<file path="Assets/_Project/Scripts/UI/TargetingUIManager.cs">
// Filename: TargetingUIManager.cs (Updated Version)

using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class TargetingUIManager : MonoBehaviour
{
    [Header("Target Frame Components")] [SerializeField]
    private GameObject _targetFramePanel;

    [SerializeField] private Slider _targetHealthSlider;
    [SerializeField] private TextMeshProUGUI _targetNameText;

    private Health _currentTargetHealth;

    private void Awake()
    {
        PlayerController.OnTargetChanged += HandleTargetChanged;
        _targetFramePanel.SetActive(false);
    }

    private void OnDestroy()
    {
        PlayerController.OnTargetChanged -= HandleTargetChanged;
        // Eski hedefin can olayından aboneliği iptal etmeyi unutma.
        if (_currentTargetHealth != null)
        {
            _currentTargetHealth.CurrentHealth.OnValueChanged -= UpdateTargetHealthUI;
        }
    }

    private void HandleTargetChanged(Targetable newTarget)
    {
        // Önceki hedefin can olayından aboneliği iptal et.
        if (_currentTargetHealth != null)
        {
            _currentTargetHealth.CurrentHealth.OnValueChanged -= UpdateTargetHealthUI;
        }

        if (newTarget)
        {
            _targetFramePanel.SetActive(true);
            var playerInfo = newTarget.GetComponent<PlayerInfo>();
            if (playerInfo)
            {
                // Hem oyuncu adını hem de gemi adını göster.
                // newTarget.gameObject.name, Unity'deki objenin adını verir.
                // playerInfo.Username.Value ise network'ten gelen oyuncu adını verir.
                _targetNameText.text = $"{playerInfo.Username.Value}\n<size=22>{newTarget.gameObject.name}</size>";
            }

            _currentTargetHealth = newTarget.GetComponent<Health>();
            if (_currentTargetHealth)
            {
                // Yeni hedefin can olayına abone ol.
                _currentTargetHealth.CurrentHealth.OnValueChanged += UpdateTargetHealthUI;
                // UI'ı ilk değerlerle güncelle.
                UpdateTargetHealthUI(0, _currentTargetHealth.CurrentHealth.Value);
            }
        }
        else
        {
            _targetFramePanel.SetActive(false);
            _currentTargetHealth = null;
        }
    }

    private void UpdateTargetHealthUI(int previousValue, int newValue)
    {
        if (_targetFramePanel.activeSelf)
        {
            _targetHealthSlider.maxValue = 100; 
            _targetHealthSlider.value = newValue;
            // İsteğe bağlı olarak can metnini de güncelleyebilirsiniz.
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/UI/UIDragHandle.cs">
// Filename: UIDragHandle.cs (Final, Robust Version)
using UnityEngine;
using UnityEngine.EventSystems;

public class UIDragHandle : MonoBehaviour, IDragHandler
{
    [Tooltip("Bu tutamaç, hangi pencereyi sürükleyecek? Genellikle parent'ıdır.")]
    [SerializeField] private RectTransform _targetRectTransform;

    private Canvas _canvas;

    private void Awake()
    {
        // Hedef atanmamışsa, kendi parent'ını sürüklemeye çalış.
        if (_targetRectTransform == null)
        {
            _targetRectTransform = transform.parent.GetComponent<RectTransform>();
        }
        
        // Bu script'in bulunduğu en üst seviye Canvas'ı bul.
        _canvas = GetComponentInParent<Canvas>();
    }

    // Fare basılı tutulup sürüklendiği her kare çalışır.
    public void OnDrag(PointerEventData eventData)
    {
        if (_targetRectTransform == null) return;

        // Farenin hareket miktarını (delta), Canvas'ın ölçeğine bölerek
        // doğru hareket miktarını buluyoruz. Bu, "Scale With Screen Size"
        // modunda doğru çalışmasını sağlar.
        _targetRectTransform.anchoredPosition += eventData.delta / _canvas.scaleFactor;
    }
}
</file>

<file path="Assets/_Project/Scripts/UI/WorldSpaceUIFollower.cs">
// Filename: WorldSpaceUIFollower.cs
using UnityEngine;

public class WorldSpaceUIFollower : MonoBehaviour
{
    [Header("Takip Ayarları")]
    [Tooltip("Bu UI elementinin takip edeceği ana obje (Gemi).")]
    [SerializeField] private Transform _targetToFollow;
    
    [Tooltip("Takip edilecek objenin merkezine göre uygulanacak mesafe.")]
    [SerializeField] private Vector3 _positionOffset = new Vector3(0, -5f, 0); // Varsayılan olarak 5 birim aşağıda

    private Camera _mainCamera;

    void Start()
    {
        _mainCamera = Camera.main;

        // Eğer hedef Inspector'dan atanmamışsa, kendi parent'ını takip etmeyi dene.
        // Bu, script'i doğrudan HealthCanvas'a koyduğumuzda işe yarar.
        if (_targetToFollow == null)
        {
            _targetToFollow = transform.parent;
        }
    }

    void LateUpdate()
    {
        if (_mainCamera == null || _targetToFollow == null) return;

        // 1. Pozisyonu Ayarla:
        // Her karede, pozisyonumuzu hedefin pozisyonu + belirlediğimiz mesafe olarak ayarla.
        transform.position = _targetToFollow.position + _positionOffset;

        // 2. Rotasyonu Ayarla (Billboard Efekti):
        // Her karede, rotasyonumuzu kameranın rotasyonuyla aynı yap.
        transform.rotation = _mainCamera.transform.rotation;
    }
}
</file>

<file path="Assets/_Project/Scripts/VFX/AutoDestroyParticle.cs">
// Filename: AutoDestroyParticle.cs
using UnityEngine;

public class AutoDestroyParticle : MonoBehaviour
{
    void Start()
    {
        // Particle sisteminin süresi bittiğinde objeyi yok et.
        Destroy(gameObject, GetComponent<ParticleSystem>().main.duration);
    }
}
</file>

<file path="Assets/Hovl Studio/Procedural fire/Shaders/FireSphere.shader">
Shader "EGA/Particles/FireSphere"
{
	Properties
	{
		_MainTex("Main Tex", 2D) = "white" {}
		_Color("Color", Color) = (1,1,1,1)
		_Emission("Emission", Float) = 2
		_StartFrequency("Start Frequency", Float) = 4
		_Frequency("Frequency", Float) = 10
		_Amplitude("Amplitude", Float) = 1
		[Toggle]_Usedepth("Use depth?", Float) = 0
		_Depthpower("Depth power", Float) = 1
		[Toggle]_Useblack("Use black", Float) = 0
		_Opacity("Opacity", Float) = 1
		[HideInInspector] _tex3coord( "", 2D ) = "white" {}
		[HideInInspector] __dirty( "", Int ) = 1
	}

	SubShader
	{
		Tags{ "RenderType" = "Transparent"  "Queue" = "Transparent+0" "IgnoreProjector" = "True" "IsEmissive" = "true"  "PreviewType"="Plane" }
		Cull Back
		CGPROGRAM
		#include "UnityShaderVariables.cginc"
		#include "UnityCG.cginc"
		#pragma target 3.0
		#pragma surface surf Unlit alpha:fade keepalpha noshadow 
		#undef TRANSFORM_TEX
		#define TRANSFORM_TEX(tex,name) float4(tex.xy * name##_ST.xy + name##_ST.zw, tex.z, tex.w)
		struct Input
		{
			float4 vertexColor : COLOR;
			float3 uv_tex3coord;
			float4 screenPos;
		};

		uniform float _Useblack;
		uniform float _Emission;
		uniform float4 _Color;
		uniform sampler2D _MainTex;
		uniform float _StartFrequency;
		uniform float _Amplitude;
		uniform float _Frequency;
		uniform float _Usedepth;
		uniform float _Opacity;
		UNITY_DECLARE_DEPTH_TEXTURE( _CameraDepthTexture );
		uniform float4 _CameraDepthTexture_TexelSize;
		uniform float _Depthpower;

		inline half4 LightingUnlit( SurfaceOutput s, half3 lightDir, half atten )
		{
			return half4 ( 0, 0, 0, s.Alpha );
		}

		void surf( Input i , inout SurfaceOutput o )
		{
			float4 temp_output_121_0 = ( _Emission * _Color * i.vertexColor );
			float2 temp_output_8_0 = ( ( ( float2( 0.2,0 ) * _Time.y ) + (i.uv_tex3coord).xy + i.uv_tex3coord.z ) * _StartFrequency );
			float2 break18 = floor( temp_output_8_0 );
			float temp_output_21_0 = ( break18.x + ( break18.y * 57.0 ) );
			float2 temp_output_10_0 = frac( temp_output_8_0 );
			float2 temp_cast_1 = (3.0).xx;
			float2 break17 = ( temp_output_10_0 * temp_output_10_0 * ( temp_cast_1 - ( temp_output_10_0 * 2.0 ) ) );
			float lerpResult39 = lerp( frac( ( 473.5 * sin( temp_output_21_0 ) ) ) , frac( ( 473.5 * sin( ( 1.0 + temp_output_21_0 ) ) ) ) , break17.x);
			float lerpResult38 = lerp( frac( ( 473.5 * sin( ( 57.0 + temp_output_21_0 ) ) ) ) , frac( ( 473.5 * sin( ( 58.0 + temp_output_21_0 ) ) ) ) , break17.x);
			float lerpResult40 = lerp( lerpResult39 , lerpResult38 , break17.y);
			float3 temp_output_51_0 = ( ( float3( ( float2( 0.5,0.5 ) * _Time.y ) ,  0.0 ) + ( i.uv_tex3coord * ( lerpResult40 * _Amplitude ) ) + i.uv_tex3coord.z ) * _Frequency );
			float3 break87 = floor( temp_output_51_0 );
			float temp_output_90_0 = ( break87.x + ( break87.y * 57.0 ) );
			float3 temp_output_52_0 = frac( temp_output_51_0 );
			float3 temp_cast_3 = (3.0).xxx;
			float3 break110 = ( temp_output_52_0 * temp_output_52_0 * ( temp_cast_3 - ( temp_output_52_0 * 2.0 ) ) );
			float lerpResult109 = lerp( frac( ( 473.5 * sin( temp_output_90_0 ) ) ) , frac( ( 473.5 * sin( ( 1.0 + temp_output_90_0 ) ) ) ) , break110.x);
			float lerpResult105 = lerp( frac( ( 473.5 * sin( ( 57.0 + temp_output_90_0 ) ) ) ) , frac( ( 473.5 * sin( ( 58.0 + temp_output_90_0 ) ) ) ) , break110.x);
			float lerpResult106 = lerp( lerpResult109 , lerpResult105 , break110.y);
			float Amp114 = _Amplitude;
			float4 tex2DNode117 = tex2D( _MainTex, ( i.uv_tex3coord + ( 0.2 * ( lerpResult106 * Amp114 ) ) ).xy );
			o.Emission = lerp(temp_output_121_0,( temp_output_121_0 * tex2DNode117 ),_Useblack).rgb;
			float4 clampResult132 = clamp( ( i.vertexColor.a * tex2DNode117 * _Opacity ) , float4( 0,0,0,0 ) , float4( 1,1,1,1 ) );
			float4 ase_screenPos = float4( i.screenPos.xyz , i.screenPos.w + 0.00000000001 );
			float4 ase_screenPosNorm = ase_screenPos / ase_screenPos.w;
			ase_screenPosNorm.z = ( UNITY_NEAR_CLIP_VALUE >= 0 ) ? ase_screenPosNorm.z : ase_screenPosNorm.z * 0.5 + 0.5;
			float screenDepth137 = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE( _CameraDepthTexture, ase_screenPosNorm.xy ));
			float distanceDepth137 = abs( ( screenDepth137 - LinearEyeDepth( ase_screenPosNorm.z ) ) / ( _Depthpower ) );
			float clampResult136 = clamp( distanceDepth137 , 0.0 , 1.0 );
			o.Alpha = lerp(clampResult132,( clampResult132 * clampResult136 ),_Usedepth).r;
		}

		ENDCG
	}
}
/*ASEBEGIN
Version=17000
165;194;1326;839;7535.3;-75.36414;2.204268;True;False
Node;AmplifyShaderEditor.Vector2Node;2;-8339.338,985.6799;Float;False;Constant;_Vector0;Vector 0;0;0;Create;True;0;0;False;0;0.2,0;0,0;0;3;FLOAT2;0;FLOAT;1;FLOAT;2
Node;AmplifyShaderEditor.TextureCoordinatesNode;6;-8473.372,1250.548;Float;False;0;-1;3;3;2;SAMPLER2D;;False;0;FLOAT2;1,1;False;1;FLOAT2;0,0;False;5;FLOAT3;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4
Node;AmplifyShaderEditor.SimpleTimeNode;3;-8341.885,1115.568;Float;False;1;0;FLOAT;1;False;1;FLOAT;0
Node;AmplifyShaderEditor.ComponentMaskNode;143;-8218.255,1183.854;Float;False;True;True;False;True;1;0;FLOAT3;0,0,0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;4;-8151.904,1094.41;Float;False;2;2;0;FLOAT2;0,0;False;1;FLOAT;0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.WireNode;144;-8009.953,1231.439;Float;False;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.RangedFloatNode;7;-8309.805,1408.944;Float;False;Property;_StartFrequency;Start Frequency;3;0;Create;True;0;0;False;0;4;4;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleAddOpNode;5;-7973.625,1096.957;Float;False;3;3;0;FLOAT2;0,0;False;1;FLOAT2;0,0;False;2;FLOAT;0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;8;-7813.932,1241.061;Float;True;2;2;0;FLOAT2;0,0;False;1;FLOAT;0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.FloorOpNode;9;-7547.65,1082.107;Float;True;1;0;FLOAT2;0,0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.BreakToComponentsNode;18;-7344.967,1083.629;Float;False;FLOAT2;1;0;FLOAT2;0,0;False;16;FLOAT;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4;FLOAT;5;FLOAT;6;FLOAT;7;FLOAT;8;FLOAT;9;FLOAT;10;FLOAT;11;FLOAT;12;FLOAT;13;FLOAT;14;FLOAT;15
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;20;-7062.681,1160.891;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;57;False;1;FLOAT;0
Node;AmplifyShaderEditor.RangedFloatNode;12;-7529.174,1580.68;Float;False;Constant;_Float1;Float 1;0;0;Create;True;0;0;False;0;2;0;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleAddOpNode;21;-6806.613,1076.975;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.FractNode;10;-7553.76,1363.48;Float;True;1;0;FLOAT2;0,0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.RangedFloatNode;14;-7318.913,1456.596;Float;False;Constant;_Float2;Float 2;0;0;Create;True;0;0;False;0;3;0;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleAddOpNode;24;-6584.13,372.1529;Float;False;2;2;0;FLOAT;58;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleAddOpNode;22;-6558.124,854.1409;Float;False;2;2;0;FLOAT;1;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;11;-7324.859,1541.259;Float;False;2;2;0;FLOAT2;0,0;False;1;FLOAT;0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.SimpleAddOpNode;23;-6558.122,586.1391;Float;False;2;2;0;FLOAT;57;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.RangedFloatNode;30;-6356.774,280.2781;Float;False;Constant;_Float3;Float 3;0;0;Create;True;0;0;False;0;473.5;0;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleSubtractOpNode;13;-7137.232,1516.901;Float;False;2;0;FLOAT;0;False;1;FLOAT2;0,0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.SinOpNode;28;-6342.376,1074.423;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SinOpNode;27;-6346.015,841.5241;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SinOpNode;25;-6352.599,368.8428;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SinOpNode;26;-6347.835,586.7913;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;31;-6081.798,583.8928;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;33;-6090.109,1070.09;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;29;-6086.764,368.9619;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;32;-6085.954,843.6132;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;15;-6956.632,1375.047;Float;True;3;3;0;FLOAT2;0,0;False;1;FLOAT2;0,0;False;2;FLOAT2;0,0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.FractNode;35;-5814.168,580.2521;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.FractNode;34;-5822.274,367.3298;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.BreakToComponentsNode;17;-5831.321,1378.868;Float;False;FLOAT2;1;0;FLOAT2;0,0;False;16;FLOAT;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4;FLOAT;5;FLOAT;6;FLOAT;7;FLOAT;8;FLOAT;9;FLOAT;10;FLOAT;11;FLOAT;12;FLOAT;13;FLOAT;14;FLOAT;15
Node;AmplifyShaderEditor.FractNode;36;-5805.767,838.3047;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.FractNode;37;-5797.52,1070.841;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.LerpOp;38;-5476.058,512.5654;Float;True;3;0;FLOAT;0;False;1;FLOAT;0;False;2;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.WireNode;41;-5269.879,1134.923;Float;False;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.LerpOp;39;-5483.018,912.7736;Float;True;3;0;FLOAT;0;False;1;FLOAT;0;False;2;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.LerpOp;40;-5117.311,718.1027;Float;True;3;0;FLOAT;0;False;1;FLOAT;0;False;2;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.RangedFloatNode;43;-5037.042,955.2929;Float;False;Property;_Amplitude;Amplitude;5;0;Create;True;0;0;False;0;1;1;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;42;-4818.819,717.6736;Float;False;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleTimeNode;47;-4804.05,458.4331;Float;False;1;0;FLOAT;1;False;1;FLOAT;0
Node;AmplifyShaderEditor.Vector2Node;46;-4812.312,329.1589;Float;False;Constant;_Vector1;Vector 1;0;0;Create;True;0;0;False;0;0.5,0.5;0,0;0;3;FLOAT2;0;FLOAT;1;FLOAT;2
Node;AmplifyShaderEditor.TextureCoordinatesNode;45;-4916.955,572.0232;Float;False;0;-1;3;3;2;SAMPLER2D;;False;0;FLOAT2;1,1;False;1;FLOAT2;0,0;False;5;FLOAT3;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;44;-4640.396,695.9497;Float;True;2;2;0;FLOAT3;0,0,0;False;1;FLOAT;0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;48;-4593.8,375.2411;Float;False;2;2;0;FLOAT2;0,0;False;1;FLOAT;0;False;1;FLOAT2;0
Node;AmplifyShaderEditor.RangedFloatNode;50;-4319.869,637.7733;Float;False;Property;_Frequency;Frequency;4;0;Create;True;0;0;False;0;10;10;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleAddOpNode;49;-4351.151,377.1398;Float;True;3;3;0;FLOAT2;0,0;False;1;FLOAT3;0,0,0;False;2;FLOAT;0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;51;-4085.566,374.4995;Float;False;2;2;0;FLOAT3;0,0,0;False;1;FLOAT;0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.FloorOpNode;54;-3872.618,372.1716;Float;True;1;0;FLOAT3;0,0,0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.BreakToComponentsNode;87;-3682.724,363.05;Float;False;FLOAT3;1;0;FLOAT3;0,0,0;False;16;FLOAT;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4;FLOAT;5;FLOAT;6;FLOAT;7;FLOAT;8;FLOAT;9;FLOAT;10;FLOAT;11;FLOAT;12;FLOAT;13;FLOAT;14;FLOAT;15
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;89;-3400.439,440.3125;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;57;False;1;FLOAT;0
Node;AmplifyShaderEditor.FractNode;52;-3877.763,629.3062;Float;True;1;0;FLOAT3;0,0,0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.SimpleAddOpNode;90;-3144.371,356.3967;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.RangedFloatNode;112;-3868.931,860.0997;Float;False;Constant;_Float6;Float 6;0;0;Create;True;0;0;False;0;2;0;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.RangedFloatNode;85;-3656.671,736.0167;Float;False;Constant;_Float4;Float 4;0;0;Create;True;0;0;False;0;3;0;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleAddOpNode;92;-2895.881,-134.4393;Float;False;2;2;0;FLOAT;57;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;84;-3662.617,820.6796;Float;False;2;2;0;FLOAT3;0,0,0;False;1;FLOAT;0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.SimpleAddOpNode;91;-2921.888,-348.4255;Float;False;2;2;0;FLOAT;58;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleAddOpNode;93;-2895.883,133.5624;Float;False;2;2;0;FLOAT;1;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SinOpNode;95;-2685.592,-133.787;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SinOpNode;94;-2690.357,-351.7355;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleSubtractOpNode;86;-3474.99,796.3214;Float;False;2;0;FLOAT;0;False;1;FLOAT3;0,0,0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.RangedFloatNode;98;-2694.532,-440.2999;Float;False;Constant;_Float5;Float 5;0;0;Create;True;0;0;False;0;473.5;0;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SinOpNode;97;-2680.133,353.8448;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SinOpNode;96;-2683.773,120.9456;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;99;-2424.521,-351.6166;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;88;-3294.389,654.4678;Float;True;3;3;0;FLOAT3;0,0,0;False;1;FLOAT3;0,0,0;False;2;FLOAT3;0,0,0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;102;-2423.712,123.0346;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;101;-2427.867,349.5115;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;100;-2419.556,-136.6857;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.FractNode;107;-2143.523,117.7261;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.BreakToComponentsNode;110;-2169.078,658.2891;Float;False;FLOAT3;1;0;FLOAT3;0,0,0;False;16;FLOAT;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4;FLOAT;5;FLOAT;6;FLOAT;7;FLOAT;8;FLOAT;9;FLOAT;10;FLOAT;11;FLOAT;12;FLOAT;13;FLOAT;14;FLOAT;15
Node;AmplifyShaderEditor.FractNode;108;-2135.276,350.2626;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.FractNode;103;-2160.031,-353.2485;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.FractNode;104;-2151.925,-140.3264;Float;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.LerpOp;105;-1813.815,-208.0128;Float;True;3;0;FLOAT;0;False;1;FLOAT;0;False;2;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.LerpOp;109;-1820.775,192.1951;Float;True;3;0;FLOAT;0;False;1;FLOAT;0;False;2;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.RegisterLocalVarNode;114;-4804.202,960.5021;Float;False;Amp;-1;True;1;0;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.LerpOp;106;-1455.067,-2.476338;Float;True;3;0;FLOAT;0;False;1;FLOAT;0;False;2;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.GetLocalVarNode;115;-1404.034,234.1648;Float;False;114;Amp;1;0;OBJECT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;113;-1181.266,-4.527974;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.RangedFloatNode;123;-1118.897,235.3207;Float;False;Constant;_Float7;Float 7;3;0;Create;True;0;0;False;0;0.2;0;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;118;-860.5004,-13.68515;Float;True;2;2;0;FLOAT;0;False;1;FLOAT;0;False;1;FLOAT;0
Node;AmplifyShaderEditor.TextureCoordinatesNode;116;-1202.528,-154.2663;Float;False;0;-1;3;3;2;SAMPLER2D;;False;0;FLOAT2;1,1;False;1;FLOAT2;0,0;False;5;FLOAT3;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4
Node;AmplifyShaderEditor.SimpleAddOpNode;125;-572.5908,-152.6133;Float;False;2;2;0;FLOAT3;0,0,0;False;1;FLOAT;0;False;1;FLOAT3;0
Node;AmplifyShaderEditor.SamplerNode;117;140.8239,117.1614;Float;True;Property;_MainTex;Main Tex;0;0;Create;True;0;0;False;0;5228a04ef529d2641937cab585cc1a02;5228a04ef529d2641937cab585cc1a02;True;0;False;white;Auto;False;Object;-1;Auto;Texture2D;6;0;SAMPLER2D;;False;1;FLOAT2;0,0;False;2;FLOAT;0;False;3;FLOAT2;0,0;False;4;FLOAT2;0,0;False;5;FLOAT;1;False;5;COLOR;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4
Node;AmplifyShaderEditor.RangedFloatNode;138;332.3323,563.8065;Float;False;Property;_Depthpower;Depth power;7;0;Create;True;0;0;False;0;1;1;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.VertexColorNode;120;220.0708,-58.2219;Float;False;0;5;COLOR;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4
Node;AmplifyShaderEditor.RangedFloatNode;131;282.9455,341.1415;Float;False;Property;_Opacity;Opacity;9;0;Create;True;0;0;False;0;1;1;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.DepthFade;137;523.3648,521.5419;Float;False;True;False;True;2;1;FLOAT3;0,0,0;False;0;FLOAT;1;False;1;FLOAT;0
Node;AmplifyShaderEditor.RangedFloatNode;122;259.26,-305.5326;Float;False;Property;_Emission;Emission;2;0;Create;True;0;0;False;0;2;2;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;126;530.514,154.4088;Float;True;3;3;0;FLOAT;0;False;1;COLOR;0,0,0,0;False;2;FLOAT;0;False;1;COLOR;0
Node;AmplifyShaderEditor.ColorNode;119;199.4791,-221.3163;Float;False;Property;_Color;Color;1;0;Create;True;0;0;False;0;1,1,1,1;1,1,1,1;True;0;5;COLOR;0;FLOAT;1;FLOAT;2;FLOAT;3;FLOAT;4
Node;AmplifyShaderEditor.ClampOpNode;136;790.9812,444.1675;Float;False;3;0;FLOAT;0;False;1;FLOAT;0;False;2;FLOAT;1;False;1;FLOAT;0
Node;AmplifyShaderEditor.ClampOpNode;132;775.0079,151.4682;Float;False;3;0;COLOR;0,0,0,0;False;1;COLOR;0,0,0,0;False;2;COLOR;1,1,1,1;False;1;COLOR;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;121;469.5908,-155.6279;Float;False;3;3;0;FLOAT;0;False;1;COLOR;0,0,0,0;False;2;COLOR;0,0,0,0;False;1;COLOR;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;139;973.0854,335.2226;Float;False;2;2;0;COLOR;0,0,0,0;False;1;FLOAT;0;False;1;COLOR;0
Node;AmplifyShaderEditor.SimpleMultiplyOpNode;130;640.5754,-58.20366;Float;False;2;2;0;COLOR;0,0,0,0;False;1;COLOR;0,0,0,0;False;1;COLOR;0
Node;AmplifyShaderEditor.ToggleSwitchNode;145;1134.603,147.4463;Float;False;Property;_Usedepth;Use depth?;6;0;Create;True;0;0;False;0;0;2;0;COLOR;0,0,0,0;False;1;COLOR;0,0,0,0;False;1;COLOR;0
Node;AmplifyShaderEditor.RangedFloatNode;129;244.175,-421.8842;Float;False;Constant;_Float0;Float 0;7;0;Create;True;0;0;False;0;1;0;0;0;0;1;FLOAT;0
Node;AmplifyShaderEditor.ToggleSwitchNode;146;800.4197,-159.0233;Float;False;Property;_Useblack;Use black;8;0;Create;True;0;0;False;0;0;2;0;COLOR;0,0,0,0;False;1;COLOR;0,0,0,0;False;1;COLOR;0
Node;AmplifyShaderEditor.StandardSurfaceOutputNode;1;1393.489,-33.16033;Float;False;True;2;Float;;0;0;Unlit;EGA/Particles/FireSphere;False;False;False;False;False;False;False;False;False;False;False;False;False;False;True;False;False;False;False;False;False;Back;0;False;-1;0;False;-1;False;0;False;-1;0;False;-1;False;0;Transparent;0.5;True;False;0;False;Transparent;;Transparent;All;True;True;True;True;True;True;True;True;True;True;True;True;True;True;True;True;True;0;False;-1;False;0;False;-1;255;False;-1;255;False;-1;0;False;-1;0;False;-1;0;False;-1;0;False;-1;0;False;-1;0;False;-1;0;False;-1;0;False;-1;False;2;15;10;25;False;0.5;False;2;5;False;-1;10;False;-1;0;0;False;-1;0;False;-1;0;False;-1;0;False;-1;0;False;0;0,0,0,0;VertexOffset;True;False;Cylindrical;False;Relative;0;;-1;-1;-1;-1;1;PreviewType=Plane;False;0;0;False;-1;-1;0;False;-1;0;0;0;False;0.1;False;-1;0;False;-1;15;0;FLOAT3;0,0,0;False;1;FLOAT3;0,0,0;False;2;FLOAT3;0,0,0;False;3;FLOAT;0;False;4;FLOAT;0;False;6;FLOAT3;0,0,0;False;7;FLOAT3;0,0,0;False;8;FLOAT;0;False;9;FLOAT;0;False;10;FLOAT;0;False;13;FLOAT3;0,0,0;False;11;FLOAT3;0,0,0;False;12;FLOAT3;0,0,0;False;14;FLOAT4;0,0,0,0;False;15;FLOAT3;0,0,0;False;0
WireConnection;143;0;6;0
WireConnection;4;0;2;0
WireConnection;4;1;3;0
WireConnection;144;0;6;3
WireConnection;5;0;4;0
WireConnection;5;1;143;0
WireConnection;5;2;144;0
WireConnection;8;0;5;0
WireConnection;8;1;7;0
WireConnection;9;0;8;0
WireConnection;18;0;9;0
WireConnection;20;0;18;1
WireConnection;21;0;18;0
WireConnection;21;1;20;0
WireConnection;10;0;8;0
WireConnection;24;1;21;0
WireConnection;22;1;21;0
WireConnection;11;0;10;0
WireConnection;11;1;12;0
WireConnection;23;1;21;0
WireConnection;13;0;14;0
WireConnection;13;1;11;0
WireConnection;28;0;21;0
WireConnection;27;0;22;0
WireConnection;25;0;24;0
WireConnection;26;0;23;0
WireConnection;31;0;30;0
WireConnection;31;1;26;0
WireConnection;33;0;30;0
WireConnection;33;1;28;0
WireConnection;29;0;30;0
WireConnection;29;1;25;0
WireConnection;32;0;30;0
WireConnection;32;1;27;0
WireConnection;15;0;10;0
WireConnection;15;1;10;0
WireConnection;15;2;13;0
WireConnection;35;0;31;0
WireConnection;34;0;29;0
WireConnection;17;0;15;0
WireConnection;36;0;32;0
WireConnection;37;0;33;0
WireConnection;38;0;35;0
WireConnection;38;1;34;0
WireConnection;38;2;17;0
WireConnection;41;0;17;1
WireConnection;39;0;37;0
WireConnection;39;1;36;0
WireConnection;39;2;17;0
WireConnection;40;0;39;0
WireConnection;40;1;38;0
WireConnection;40;2;41;0
WireConnection;42;0;40;0
WireConnection;42;1;43;0
WireConnection;44;0;45;0
WireConnection;44;1;42;0
WireConnection;48;0;46;0
WireConnection;48;1;47;0
WireConnection;49;0;48;0
WireConnection;49;1;44;0
WireConnection;49;2;45;3
WireConnection;51;0;49;0
WireConnection;51;1;50;0
WireConnection;54;0;51;0
WireConnection;87;0;54;0
WireConnection;89;0;87;1
WireConnection;52;0;51;0
WireConnection;90;0;87;0
WireConnection;90;1;89;0
WireConnection;92;1;90;0
WireConnection;84;0;52;0
WireConnection;84;1;112;0
WireConnection;91;1;90;0
WireConnection;93;1;90;0
WireConnection;95;0;92;0
WireConnection;94;0;91;0
WireConnection;86;0;85;0
WireConnection;86;1;84;0
WireConnection;97;0;90;0
WireConnection;96;0;93;0
WireConnection;99;0;98;0
WireConnection;99;1;94;0
WireConnection;88;0;52;0
WireConnection;88;1;52;0
WireConnection;88;2;86;0
WireConnection;102;0;98;0
WireConnection;102;1;96;0
WireConnection;101;0;98;0
WireConnection;101;1;97;0
WireConnection;100;0;98;0
WireConnection;100;1;95;0
WireConnection;107;0;102;0
WireConnection;110;0;88;0
WireConnection;108;0;101;0
WireConnection;103;0;99;0
WireConnection;104;0;100;0
WireConnection;105;0;104;0
WireConnection;105;1;103;0
WireConnection;105;2;110;0
WireConnection;109;0;108;0
WireConnection;109;1;107;0
WireConnection;109;2;110;0
WireConnection;114;0;43;0
WireConnection;106;0;109;0
WireConnection;106;1;105;0
WireConnection;106;2;110;1
WireConnection;113;0;106;0
WireConnection;113;1;115;0
WireConnection;118;0;123;0
WireConnection;118;1;113;0
WireConnection;125;0;116;0
WireConnection;125;1;118;0
WireConnection;117;1;125;0
WireConnection;137;0;138;0
WireConnection;126;0;120;4
WireConnection;126;1;117;0
WireConnection;126;2;131;0
WireConnection;136;0;137;0
WireConnection;132;0;126;0
WireConnection;121;0;122;0
WireConnection;121;1;119;0
WireConnection;121;2;120;0
WireConnection;139;0;132;0
WireConnection;139;1;136;0
WireConnection;130;0;121;0
WireConnection;130;1;117;0
WireConnection;145;0;132;0
WireConnection;145;1;139;0
WireConnection;146;0;121;0
WireConnection;146;1;130;0
WireConnection;1;2;146;0
WireConnection;1;9;145;0
ASEEND*/
//CHKSM=BA134D5A112370580FAC7DC7683741E7C1BC9DF0
</file>

<file path="Assets/TwoUncleVFX/Common/Script/BulletController.cs">
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.VFX;

namespace VFXTools
{
	public enum TowardType
	{
		Forward,
		Right
	}
	public class BulletController : MonoBehaviour
	{
		public float rotationSpeed = 100f; 
		public float movementSpeed = 10f;
		public float delayTime = 0f;
		private bool isPlay = false;
		public float time = 1f;
		private float lastTime = 0f;
		private Vector3 startPos;
		public TowardType towardType = TowardType.Forward;
		private Vector3 directionToCenter;
		private Vector3 scale;
		private VisualEffect[] vfxs;
		private TrailRenderer[] trails;
		public float maxDistance = 100f;
		float curDistance = 0f;
		private void Start()
		{
			vfxs = GetComponentsInChildren<VisualEffect>(false);
			trails = GetComponentsInChildren<TrailRenderer>(false);
			startPos = transform.position;
			SetPlay(true);
		}

		private async void SetPlay(bool play)
		{
			//await Task.Delay((int)(delayTime * 1000));
			isPlay = play;
		}
		private void Update()
		{
			if (Input.GetKeyUp(KeyCode.Space))
			{
				isPlay = !isPlay;
			}
			if(!isPlay) return;
			lastTime += Time.deltaTime;
			if (lastTime > time)
			{
				scale = transform.localScale;
				for (int i = 0; i < vfxs.Length; i++)
				{
					vfxs[i].enabled = false;
				}
				for (int i = 0; i < trails.Length; i++)
				{
					trails[i].enabled = false;
				}
				transform.localScale = Vector3.zero;
				transform.position = startPos;
				lastTime = 0f;
				curDistance = 0f;
				transform.localScale = scale;
				isPlay = false;
				DelayEnable();
				return;
			}
			if (delayTime > lastTime || curDistance > maxDistance)
			{
				return;
			}
			directionToCenter = transform.forward;
			Quaternion targetRotation = Quaternion.LookRotation(directionToCenter);
			transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);
			if (towardType == TowardType.Forward)
			{
				transform.Translate(Vector3.forward * movementSpeed * Time.deltaTime);
			}
			else if (towardType == TowardType.Right)
			{
				transform.Translate(Vector3.right * movementSpeed * Time.deltaTime);
			}
			curDistance += movementSpeed * Time.deltaTime;
		}
		public async void DelayEnable()
		{
			await Task.Delay(500);
			for (int i = 0; i < vfxs.Length; i++)
			{
				vfxs[i].enabled = true;
			}
			for (int i = 0; i < trails.Length; i++)
			{
				trails[i].enabled = true;
			}
			isPlay = true;
		}
	}

}
</file>

<file path="Assets/TwoUncleVFX/Common/Script/BulletController2.cs">
using System.Threading.Tasks;
using UnityEngine;

namespace VFXTools
{
	public class BulletController2 : MonoBehaviour
	{
		public Transform rotationCenter;   
		public float rotationSpeed = 100f; 
		public float movementSpeed = 10f;
		public float delayTime = 0f;
		private bool isPlay = false;

		private void Start()
		{
			SetPlay(true);
		}

		private async void SetPlay(bool play)
		{
			await Task.Delay((int)(delayTime * 1000));
			isPlay = play;
		}
		private void Update()
		{
			if (Input.GetKeyUp(KeyCode.Space))
			{
				isPlay = !isPlay;
			}
			if(!isPlay) return;
			Vector3 directionToCenter = rotationCenter.position - transform.position;
			Quaternion targetRotation = Quaternion.LookRotation(directionToCenter);
			transform.rotation = Quaternion.RotateTowards(transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);
			transform.Translate(Vector3.forward * movementSpeed * Time.deltaTime);
		}
	}
}
</file>

<file path="Assets/TwoUncleVFX/Common/Script/ChangeFX.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace VFXTools
{
	public class ChangeFX : MonoBehaviour
	{
		public List<GameObject> FX;
		float time;
		public float waitTime = 5f;
		void Start()
		{
			FX.ForEach(obj => obj.SetActive(false));
			FX[0].SetActive(true);
		}

		// Update is called once per frame
		void Update()
		{
			if (Input.GetKeyUp(KeyCode.Tab))
			{
				DoChangeFX();
			}
			else if (time < waitTime)
			{
				time += Time.deltaTime;
			}
			else if (time >= waitTime)
			{
				DoChangeFX();
			}
		}

		void DoChangeFX()
		{
			time = 0;
			var index = FX.FindIndex(obj => obj.activeSelf);
			if (index < FX.Count - 1)
			{
				FX[index].SetActive(false);
				FX[index + 1].SetActive(true);
			}
			else
			{
				FX[index].SetActive(false);
				FX[0].SetActive(true);
			}
		}
	}
}
</file>

<file path="Assets/TwoUncleVFX/Common/Script/ChangeFX2.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace VFXTools
{
	public class ChangeFX2 : MonoBehaviour
	{
		public List<GameObject> FX;
		float time;
		public float waitTime = 1f;
		void Start()
		{
			FX.ForEach(obj => obj.SetActive(true));
		}

		// Update is called once per frame
		void Update()
		{
			if (Input.GetKeyUp(KeyCode.Tab))
			{
				DoChangeFX();
			}
			else if (time < waitTime)
			{
				time += Time.deltaTime;
			}
			else if (time >= waitTime)
			{
				DoChangeFX();
			}
		}

		void DoChangeFX()
		{
			time = 0;
			FX.ForEach(obj => obj.SetActive(false));
			FX.ForEach(obj => obj.SetActive(true));

		}
	}
}
</file>

<file path="Assets/TwoUncleVFX/Common/Script/ChangeFXParameter.cs">
using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.VFX;

namespace VFXTools
{
	public class ChangeFXParameter : MonoBehaviour
	{
		private VisualEffect FX;
		float time = 0;
		public string parameterName = "Radius";
		public float minValue = 0;
		public float maxValue = 1;
		void Start()
		{
			FX = GetComponent<VisualEffect>();
		}

		// Update is called once per frame
		void Update()
		{
			time +=2f * Time.deltaTime;
			DoChangeFX();
		}
		private void DoChangeFX()
		{
			FX.SetFloat(parameterName, minValue + (maxValue - minValue) * (float)Math.Abs(Math.Sin(time)));
		}
	}
}
</file>

<file path="Assets/TwoUncleVFX/Common/Script/CheckMSAA.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

namespace VFXTools
{
	public class CheckMSAA : MonoBehaviour
	{
		public Volume volume;
		void Start()
		{
			if (volume == null)
				volume = gameObject.GetComponent<Volume>();
			if (volume != null)
				if (QualitySettings.antiAliasing > 0 && Camera.main != null && Camera.main.allowMSAA)
				{
					volume.enabled = false;
				}
				else
				{
					volume.enabled = true;
				}
		}
	}
}
</file>

<file path="Assets/TwoUncleVFX/Common/Script/LineManager.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace VFXTools
{
	[ExecuteInEditMode]
	public class LineManager : MonoBehaviour
	{
		public LineRenderer line;
		public Transform pos1;
		public Transform pos2;
		void Start()
		{
			line.positionCount = 2;
		}

		void Update()
		{
			line.SetPosition(0, pos1.position);
			line.SetPosition(1, pos2.position);
		}
	}
}
</file>

<file path="Assets/TwoUncleVFX/Common/Script/RotateAround.cs">
using UnityEngine;

namespace VFXTools
{
    public class RotateAround : MonoBehaviour
    {
        public Transform target;            
        public float rotationSpeed = 30.0f; 
        public float rotationRadius = 2.0f; 
        private Vector3 initialPosition;

        void Start()
        {
            initialPosition = transform.position;
        }

        void Update()
        {
            if (target != null)
            {
                float angle = Time.time * rotationSpeed;
                float x = initialPosition.x + rotationRadius * Mathf.Cos(angle);
                float z = initialPosition.z + rotationRadius * Mathf.Sin(angle);

                transform.position = new Vector3(x, transform.position.y, z);

                transform.LookAt(target, Vector3.up);
            }
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/Api/CannonballApiService.cs">
// Filename: CannonballApiService.cs

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using BarbarosKs.Shared.DTOs;

public class CannonballApiService : BaseApiService, IGameService
{
    public async Task<List<CannonballDto>> GetAllCannonballTypesAsync()
    {
        // Bu genel bir oyun verisi olduğu için kimlik doğrulaması gerektirmez.
        return await GetAsync<List<CannonballDto>>("/api/cannonballs/all", false);
    }
    
}
</file>

<file path="Assets/_Project/Scripts/Core/BaseApiService.cs">
// Filename: BaseApiService.cs (Final, Complete Version)
using System;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using UnityEngine;

public abstract class BaseApiService
{
    private const string API_BASE_URL = "https://localhost:7272";
    private const string SERVER_SECRET_KEY = "BarbarosKs_SuperGizli_Sunucu_Anahtari_12345";

    protected static readonly HttpClient HttpClient;
    protected static string JwtToken;

    static BaseApiService()
    {
        HttpClient = new HttpClient { BaseAddress = new Uri(API_BASE_URL) };
        // This secret key is for server-to-server communication, ensuring that
        // requests from our Unity server are trusted by the Web API.
        HttpClient.DefaultRequestHeaders.Add("X-Server-Secret", SERVER_SECRET_KEY);
    }

    protected void SetToken(string token)
    {
        JwtToken = token;
        // This adds the player's JWT token for player-specific actions.
        HttpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", JwtToken);
    }

	/// <summary>
	/// Returns the currently stored JWT token (if any).
	/// </summary>
	protected static string GetToken()
	{
		return JwtToken;
	}

	/// <summary>
	/// Clears the currently stored JWT token and removes the Authorization header from the shared HttpClient.
	/// </summary>
	protected static void ClearToken()
	{
		JwtToken = null;
		HttpClient.DefaultRequestHeaders.Authorization = null;
	}

    protected static async Task<T> GetAsync<T>(string endpoint, bool requireAuth = true)
    {
        if (requireAuth && string.IsNullOrEmpty(JwtToken))
        {
            Debug.LogError($"Authentication required, but no token found for GET request: {endpoint}");
            return default;
        }

        try
        {
            var response = await HttpClient.GetAsync(endpoint);
            var responseJson = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                return JsonConvert.DeserializeObject<T>(responseJson);
            }

            Debug.LogError($"API GET Error: {response.StatusCode} - {responseJson} ({endpoint})");
            return default;
        }
        catch (Exception e)
        {
            Debug.LogError($"Exception during API GET request: {e.Message} ({endpoint})");
            return default;
        }
    }

	/// <summary>
	/// GET with per-request override token support. If overrideToken is provided, it will be used only for this request.
	/// </summary>
	protected static async Task<T> GetAsync<T>(string endpoint, bool requireAuth, string overrideToken)
	{
		if (requireAuth && string.IsNullOrEmpty(overrideToken) && string.IsNullOrEmpty(JwtToken))
		{
			Debug.LogError($"Authentication required, but no token found for GET request: {endpoint}");
			return default;
		}

		try
		{
			using (var request = new HttpRequestMessage(HttpMethod.Get, endpoint))
			{
				if (requireAuth && !string.IsNullOrEmpty(overrideToken))
				{
					request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", overrideToken);
				}

				var response = await HttpClient.SendAsync(request);
				var responseJson = await response.Content.ReadAsStringAsync();

				if (response.IsSuccessStatusCode)
				{
					return JsonConvert.DeserializeObject<T>(responseJson);
				}

				Debug.LogError($"API GET Error: {response.StatusCode} - {responseJson} ({endpoint})");
				return default;
			}
		}
		catch (Exception e)
		{
			Debug.LogError($"Exception during API GET request: {e.Message} ({endpoint})");
			return default;
		}
	}

    protected async Task<TResponse> PostAsync<TRequest, TResponse>(string endpoint, TRequest payload, bool requireAuth = true)
    {
        if (requireAuth && string.IsNullOrEmpty(JwtToken))
        {
            Debug.LogError($"Authentication required, but no token found for POST request: {endpoint}");
            return default;
        }

        try
        {
            var jsonPayload = JsonConvert.SerializeObject(payload);
            var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

            var response = await HttpClient.PostAsync(endpoint, content);
            var responseJson = await response.Content.ReadAsStringAsync();

            if (response.IsSuccessStatusCode)
            {
                return JsonConvert.DeserializeObject<TResponse>(responseJson);
            }

            
            // Try to deserialize regardless of status code, as the body might contain error details.
            try { return JsonConvert.DeserializeObject<TResponse>(responseJson); }
            catch { return default; } // Eğer bu da başarısız olursa, null dön.
        }
        catch (Exception e)
        {
            Debug.LogError($"Exception during API POST request: {e.Message} ({endpoint})");
            return default;
        }
    }

	/// <summary>
	/// POST with per-request override token support. If overrideToken is provided, it will be used only for this request.
	/// </summary>
	protected async Task<TResponse> PostAsync<TRequest, TResponse>(string endpoint, TRequest payload, bool requireAuth, string overrideToken)
	{
		if (requireAuth && string.IsNullOrEmpty(overrideToken) && string.IsNullOrEmpty(JwtToken))
		{
			Debug.LogError($"Authentication required, but no token found for POST request: {endpoint}");
			return default;
		}

		try
		{
			var jsonPayload = JsonConvert.SerializeObject(payload);
			var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

			using (var request = new HttpRequestMessage(HttpMethod.Post, endpoint))
			{
				request.Content = content;
				if (requireAuth && !string.IsNullOrEmpty(overrideToken))
				{
					request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", overrideToken);
				}

				var response = await HttpClient.SendAsync(request);
				var responseJson = await response.Content.ReadAsStringAsync();

				if (response.IsSuccessStatusCode)
				{
					return JsonConvert.DeserializeObject<TResponse>(responseJson);
				}

				try { return JsonConvert.DeserializeObject<TResponse>(responseJson); }
				catch { return default; }
			}
		}
		catch (Exception e)
		{
			Debug.LogError($"Exception during API POST request: {e.Message} ({endpoint})");
			return default;
		}
	}

    /// <summary>
    /// Sends a PUT request to the specified endpoint to update a resource.
    /// </summary>
    protected async Task<TResponse> PutAsync<TRequest, TResponse>(string endpoint, TRequest payload, bool requireAuth = true)
    {
        if (requireAuth && string.IsNullOrEmpty(JwtToken))
        {
            Debug.LogError($"Authentication required, but no token found for PUT request: {endpoint}");
            return default;
        }

        try
        {
            var jsonPayload = JsonConvert.SerializeObject(payload);
            var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

			using (var request = new HttpRequestMessage(HttpMethod.Put, endpoint))
			{
				request.Content = content;
				var response = await HttpClient.SendAsync(request);
				var responseJson = await response.Content.ReadAsStringAsync();
				return JsonConvert.DeserializeObject<TResponse>(responseJson);
			}
        }
        catch (Exception e)
        {
            Debug.LogError($"Exception during API PUT request: {e.Message} ({endpoint})");
            return default;
        }
    }

	/// <summary>
	/// PUT with per-request override token support. If overrideToken is provided, it will be used only for this request.
	/// </summary>
	protected async Task<TResponse> PutAsync<TRequest, TResponse>(string endpoint, TRequest payload, bool requireAuth, string overrideToken)
	{
		if (requireAuth && string.IsNullOrEmpty(overrideToken) && string.IsNullOrEmpty(JwtToken))
		{
			Debug.LogError($"Authentication required, but no token found for PUT request: {endpoint}");
			return default;
		}

		try
		{
			var jsonPayload = JsonConvert.SerializeObject(payload);
			var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

			using (var request = new HttpRequestMessage(HttpMethod.Put, endpoint))
			{
				request.Content = content;
				if (requireAuth && !string.IsNullOrEmpty(overrideToken))
				{
					request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", overrideToken);
				}

				var response = await HttpClient.SendAsync(request);
				var responseJson = await response.Content.ReadAsStringAsync();
				return JsonConvert.DeserializeObject<TResponse>(responseJson);
			}
		}
		catch (Exception e)
		{
			Debug.LogError($"Exception during API PUT request: {e.Message} ({endpoint})");
			return default;
		}
	}

    /// <summary>
    /// Sends a DELETE request to the specified endpoint to delete a resource.
    /// </summary>
    /// <returns>True if the deletion was successful (e.g., 200 OK or 204 No Content), false otherwise.</returns>
    protected async Task<bool> DeleteAsync(string endpoint, bool requireAuth = true)
    {
        if (requireAuth && string.IsNullOrEmpty(JwtToken))
        {
            Debug.LogError($"Authentication required, but no token found for DELETE request: {endpoint}");
            return false;
        }

        try
        {
			var response = await HttpClient.DeleteAsync(endpoint);
            
            if (!response.IsSuccessStatusCode)
            {
                var responseJson = await response.Content.ReadAsStringAsync();
                Debug.LogError($"API DELETE Error: {response.StatusCode} - {responseJson} ({endpoint})");
            }

            return response.IsSuccessStatusCode;
        }
        catch (Exception e)
        {
            Debug.LogError($"Exception during API DELETE request: {e.Message} ({endpoint})");
            return false;
        }
    }

	/// <summary>
	/// DELETE with per-request override token support. If overrideToken is provided, it will be used only for this request.
	/// </summary>
	protected async Task<bool> DeleteAsync(string endpoint, bool requireAuth, string overrideToken)
	{
		if (requireAuth && string.IsNullOrEmpty(overrideToken) && string.IsNullOrEmpty(JwtToken))
		{
			Debug.LogError($"Authentication required, but no token found for DELETE request: {endpoint}");
			return false;
		}

		try
		{
			using (var request = new HttpRequestMessage(HttpMethod.Delete, endpoint))
			{
				if (requireAuth && !string.IsNullOrEmpty(overrideToken))
				{
					request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", overrideToken);
				}

				var response = await HttpClient.SendAsync(request);
				if (!response.IsSuccessStatusCode)
				{
					var responseJson = await response.Content.ReadAsStringAsync();
					Debug.LogError($"API DELETE Error: {response.StatusCode} - {responseJson} ({endpoint})");
				}

				return response.IsSuccessStatusCode;
			}
		}
		catch (Exception e)
		{
			Debug.LogError($"Exception during API DELETE request: {e.Message} ({endpoint})");
			return false;
		}
	}
}
</file>

<file path="Assets/_Project/Scripts/Core/GameDataService.cs">
// Filename: GameDataService.cs
using System.Collections.Generic;
using System.Linq;
using BarbarosKs.Shared.DTOs;

public class GameDataService : IGameService
{
    private readonly Dictionary<int, CannonballDto> _cannonballTypesByCode = new();

    /// <summary>
    /// API'den gelen verilerle kütüphaneyi doldurur.
    /// </summary>
    public void Initialize(List<CannonballDto> allCannonballTypes)
    {
        _cannonballTypesByCode.Clear();
        if (allCannonballTypes == null) return;
        
        foreach (var type in allCannonballTypes)
        {
            _cannonballTypesByCode[type.Code] = type;
        }
    }

    /// <summary>
    /// Code'a göre bir güllenin tüm API verilerini getirir.
    /// </summary>
    public CannonballDto GetCannonballStatsByCode(int code)
    {
        _cannonballTypesByCode.TryGetValue(code, out var stats);
        return stats; // Bulamazsa null döner.
    }
}
</file>

<file path="Assets/_Project/Scripts/Core/GameManager.cs">
// Filename: GameManager.cs

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using BarbarosKs.Shared.DTOs;
using Unity.Netcode;
using UnityEngine;
using UnityEngine.SceneManagement;


public class GameManager : MonoBehaviour
{
    public static GameManager Instance { get; private set; }
    public NpcData TestNpcData;
    [Header("Network Prefabs")] public GameObject ShipPrefab;
    [Header("Game Databases")] public CannonballDatabase CannonballDatabase;

    private readonly Dictionary<ulong, Guid> _clientShipSelections = new();
    private PlayerManager _playerManager;

    private void Awake()
    {
        if (Instance != null && Instance != this)
        {
            Destroy(gameObject);
            return;
        }

        Instance = this;
        DontDestroyOnLoad(gameObject);
        InitializeServices();
    }

    private async void Start()
    {
        if (NetworkManager.Singleton != null)
        {
            NetworkManager.Singleton.ConnectionApprovalCallback = ConnectionApprovalCheck;
            NetworkManager.Singleton.OnServerStarted += OnServerReady;
        }

        await InitializeGameDataAsync();
    }


    private void OnServerReady()
    {
        Debug.Log("[GameManager] Sunucu başarıyla başlatıldı.");

        // Sahne olaylarını dinlemeye başla.
        NetworkManager.Singleton.SceneManager.OnLoadComplete += OnClientLoadComplete;

        // --- YENİ VE KRİTİK ADIM ---
        // Sunucu, hazır olur olmaz tüm mevcut ve gelecek client'ları "Main" sahnesine yönlendirir.
        Debug.Log("[GameManager] 'Main' sahnesi yükleniyor...");
        NetworkManager.Singleton.SceneManager.LoadScene("Main", LoadSceneMode.Single);

        var npcManager = ServiceLocator.Current.Get<NpcManager>();
        npcManager.Initialize(TestNpcData);
        npcManager.SpawnTestNpcs();
    }

    private void InitializeServices()
    {
        var serviceLocator = new ServiceLocator();

        serviceLocator.Register(new AuthApiService());
        serviceLocator.Register(new PlayerApiService());
        serviceLocator.Register(new GameDataService());
        serviceLocator.Register(new CannonballApiService());
        serviceLocator.Register(new GameSession());
        serviceLocator.Register(new PlayerInventory());
        serviceLocator.Register(new NpcManager());
        // ServerSessionManager, MonoBehaviour olduğu için AddComponent ile eklenmeli.
        // Sadece sunucu tarafında çalışması gerekse de, ServiceLocator'da null check ile uğraşmamak için
        // ekleyebiliriz, kendi içinde IsServer kontrolü zaten var.
        var sessionManager = gameObject.AddComponent<ServerSessionManager>();
        serviceLocator.Register(sessionManager);
        Debug.Log("[GameManager] ServerSessionManager servislere eklendi.");
        _playerManager = new PlayerManager();
        serviceLocator.Register(_playerManager);
    }

    private void ConnectionApprovalCheck(NetworkManager.ConnectionApprovalRequest request,
        NetworkManager.ConnectionApprovalResponse response)
    {
        var clientId = request.ClientNetworkId;
        var payloadBytes = request.Payload;
        Guid selectedShipId;

        // --- YENİ VE DAHA BASİT MANTIK ---
        // Eğer bağlanan kişi Host/Editor ise, gemi ID'sini lokal GameSession'dan al.
        if (clientId == NetworkManager.Singleton.LocalClientId)
        {
            selectedShipId = ServiceLocator.Current.Get<GameSession>().SelectedShipId;
        }
        // Eğer uzak bir Client ise, payload'dan al.
        else
        {
            var payloadJson = System.Text.Encoding.UTF8.GetString(payloadBytes);
            var payload = JsonUtility.FromJson<ConnectionPayload>(payloadJson);
            selectedShipId = new Guid(payload.shipId);
        }

        if (selectedShipId != Guid.Empty)
        {
            Debug.Log($"[GameManager] Onay Başarılı! Client {clientId} için gemi {selectedShipId} sıraya eklendi.");
            // Onaylanan gemi ID'sini, sahne yüklendiğinde kullanmak üzere sakla.
            _clientShipSelections[clientId] = selectedShipId;
            response.Approved = true;
            response.CreatePlayerObject = false;
        }
        else
        {
            Debug.LogError($"[GameManager] Onay BAŞARISIZ! Client {clientId} için geçerli bir gemi ID'si bulunamadı.");
            response.Approved = false;
        }
    }

    private void OnClientLoadComplete(ulong clientId, string sceneName, LoadSceneMode loadSceneMode)
    {
        if (sceneName != "Main") return;

        // --- YENİ VE DAHA BASİT MANTIK ---
        // Dedicated Server'ın kendisi için (clientId=0) oyuncu spawn etmesini engellemeye GEREK YOK,
        // çünkü ConnectionApproval'da onun için bir gemi ID'si hiç saklanmadı.

        if (_clientShipSelections.TryGetValue(clientId, out Guid shipId))
        {
            Debug.Log($"[GameManager] Main sahnesi yüklendi. Client {clientId} için spawn işlemi başlatılıyor.");
            _playerManager.SpawnPlayer(clientId, shipId);
            _clientShipSelections.Remove(clientId); // Spawn ettikten sonra listeden kaldır.
        }
        else
        {
            // Bu log, sadece Dedicated Server (clientId=0) için görünmeli, bu normaldir.
            Debug.LogWarning(
                $"[GameManager] Client {clientId} için spawn edilecek gemi bulunamadı (Bu bir Dedicated Server olabilir).");
        }
    }


    private async Task InitializeGameDataAsync()
    {
        var cannonballApi = ServiceLocator.Current.Get<CannonballApiService>();
        List<CannonballDto> typesFromApi = await cannonballApi.GetAllCannonballTypesAsync();

        if (typesFromApi != null)
        {
            var gameDataService = ServiceLocator.Current.Get<GameDataService>();
            gameDataService.Initialize(typesFromApi);
            Debug.Log($"API'den {typesFromApi.Count} gülle tipi verisi yüklendi.");
        }
    }

    // Obje yok edildiğinde abonelikten çıkmayı unutmuyoruz.
    private void OnDestroy()
    {
        if (NetworkManager.Singleton == null) return;
        NetworkManager.Singleton.ConnectionApprovalCallback -= ConnectionApprovalCheck;
        NetworkManager.Singleton.OnServerStarted -= OnServerReady;
        if (NetworkManager.Singleton.SceneManager != null)
        {
            NetworkManager.Singleton.SceneManager.OnLoadComplete -= OnClientLoadComplete;
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/Data/ShipStatsData.cs">
using Unity.Netcode;


//Burası gemi oluşturken clientte gödnerilecek tüm datayı içerir
public struct ShipStatsData : INetworkSerializable
{
    public float Speed;
    public float Maneuverability;
    public float HitRate;
    public float Range;
    public float Armor;
    public int CurrentVigor;
    public float Cooldown;

    public void NetworkSerialize<T>(BufferSerializer<T> serializer) where T : IReaderWriter
    {
        serializer.SerializeValue(ref Speed);
        serializer.SerializeValue(ref Maneuverability);
        serializer.SerializeValue(ref HitRate);
        serializer.SerializeValue(ref Range);
        serializer.SerializeValue(ref Armor);
        serializer.SerializeValue(ref CurrentVigor);
        serializer.SerializeValue(ref Cooldown);
    }
}
</file>

<file path="Assets/_Project/Scripts/Health.cs">
// Filename: Health.cs (Simplified Version)

using System.Collections;
using Unity.Netcode;
using UnityEngine;
using UnityEngine.UI;

public class Health : NetworkBehaviour
{
    [Header("Health Settings")]
    [SerializeField] private int _maxHealth;
    [SerializeField] private Slider _healthBar;
    
    [Header("Destruction Settings")]
    [SerializeField] private GameObject _destructionEffectPrefab; // Yok olma efekti (patlama, batma vb.)
    [SerializeField] private float _destructionDelay = 1.5f; // Efektin oynatılacağı süre

    public NetworkVariable<int> MaxHealth = new NetworkVariable<int>(100);
    public NetworkVariable<int> CurrentHealth = new NetworkVariable<int>();
    
    // Geminin ölüm sürecinde olup olmadığını tüm client'lara bildirir.
    private NetworkVariable<bool> _isDead = new NetworkVariable<bool>(false);
    public void Initialize(int maxHealth, int currentHealth)
    {
		if (!IsServer)
		{
			Debug.LogWarning($"[Health {NetworkObjectId}] Initialize clientta çağrıldı, yoksayılıyor.");
			return;
		}
		Debug.Log($"[Health {NetworkObjectId}] Initialize(SERVER) çağrıldı | Max={maxHealth} Current={currentHealth}");
        MaxHealth.Value = maxHealth;
        CurrentHealth.Value = currentHealth;
        _isDead.Value = false;
		if (CurrentHealth.Value <= 0)
		{
			Debug.LogWarning($"[Health {NetworkObjectId}] Initialize sonrası CurrentHealth <= 0! Gemi ölü spawn olabilir.");
		}
    }

    public override void OnNetworkSpawn()
    {
        // Olaylara abone ol.
        MaxHealth.OnValueChanged += OnMaxHealthChanged;
        CurrentHealth.OnValueChanged += OnCurrentHealthChanged;

		Debug.Log($"[Health {NetworkObjectId}] OnNetworkSpawn | IsServer={IsServer} Max={MaxHealth.Value} Current={CurrentHealth.Value}");
        // Başlangıç değerlerini UI'a yansıt.
        OnMaxHealthChanged(0, MaxHealth.Value);
        OnCurrentHealthChanged(0, CurrentHealth.Value);
    }

    public override void OnNetworkDespawn()
    {
        // Abonelikten çık.
        MaxHealth.OnValueChanged -= OnMaxHealthChanged;
        CurrentHealth.OnValueChanged -= OnCurrentHealthChanged;
    }

    private void OnMaxHealthChanged(int previousValue, int newValue)
    {
        if (_healthBar) _healthBar.maxValue = newValue;
		Debug.Log($"[Health {NetworkObjectId}] MaxHealth değişti: {previousValue} -> {newValue}");
    }

    private void OnCurrentHealthChanged(int previousValue, int newValue)
    {
        if (_healthBar) _healthBar.value = newValue;
		Debug.Log($"[Health {NetworkObjectId}] CurrentHealth değişti: {previousValue} -> {newValue}");
    }

    public void TakeDamage(int damage)
    {
		if (!IsServer || _isDead.Value) return; 
		if (damage <= 0)
		{
			Debug.LogWarning($"[Health {NetworkObjectId}] Sıfır/negatif damage yoksayıldı: {damage}");
			return;
		}
		Debug.Log($"[Health {NetworkObjectId}] TakeDamage(SERVER): {damage} | Before={CurrentHealth.Value}");
        
        CurrentHealth.Value = Mathf.Max(0, CurrentHealth.Value - damage);
        
        if (CurrentHealth.Value <= 0)
        {
            // --- ÖLÜM SÜRECİNİ BAŞLAT ---
            _isDead.Value = true;
			Debug.Log($"[Health {NetworkObjectId}] ÖLÜM tetiklendi. Yok edilme gecikmesi: {_destructionDelay}s");
            // StartDestructionSequenceClientRpc(); // Tüm client'lara animasyonu başlatmalarını söyle.
            StartCoroutine(DestroyAfterDelay());  // Sunucuda, gecikmeli yok etme işlemini başlat.

        }
    }
    
    // [ClientRpc]
    // private void StartDestructionSequenceClientRpc()
    // {
    //     // Bu kod, sunucu dahil tüm client'larda çalışır.
    //     Debug.Log($"Gemi {NetworkObjectId} için yok olma sekansı client'ta başlatıldı.");
    //
    //     // Görsel efektleri oynat
    //     if (_destructionEffectPrefab != null)
    //     {
    //         Instantiate(_destructionEffectPrefab, transform.position, transform.rotation);
    //     }
    //
    //     // Eğer bu geminin sahibi bizsek, kontrolleri devre dışı bırak.
    //     if (IsOwner)
    //     {
    //         GetComponent<PlayerController>().DisableControls();
    //     }
    //
    //     // Gemi modelini ve UI'ı gizle
    //     // (Renderer'ları ve Canvas'ı kapatarak gemiyi görünmez yapabiliriz)
    //     // Örnek: GetComponentInChildren<MeshRenderer>().enabled = false;
    //     // Örnek: transform.Find("HealthCanvas").gameObject.SetActive(false);
    // }
    
    private IEnumerator DestroyAfterDelay()
    {
        // Bu coroutine SADECE SUNUCUDA çalışır.
        yield return new WaitForSeconds(_destructionDelay);
		Debug.Log($"[Health {NetworkObjectId}] Despawn çağrılıyor.");
        // Belirtilen süre sonunda, network objesini tüm client'lardan kaldır.
        GetComponent<NetworkObject>().Despawn(true);
    }
}
</file>

<file path="Assets/_Project/Scripts/PlayerController.cs">
// Filename: PlayerController.cs (Restored Server-Authoritative Logic with DETAILED LOGGING)

using System;
using Unity.Netcode;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.EventSystems;
using UnityEngine.InputSystem;

[RequireComponent(typeof(NavMeshAgent))]
public class PlayerController : NetworkBehaviour
{
    // --- Olaylar ---
    public static event Action<Transform> OnLocalPlayerShipReady;
    public static event Action<Targetable> OnTargetChanged;

    // --- Referanslar ve Ayarlar ---
    [Header("Görsel Ayarlar")] [SerializeField]
    private GameObject _moveFlagPrefab;

    public Transform _cannonSpawnPoint;

    [Header("Katman Maskeleri")] [SerializeField]
    private LayerMask _movementLayerMask;

    [SerializeField] private LayerMask _targetLayerMask;

    // --- Durum Değişkenleri ---
    public Targetable CurrentTarget { get; private set; }
    private NavMeshAgent _navMeshAgent;
    private Camera _mainCamera;
    private PlayerInputActions _playerInputActions;
    private GameObject _currentMoveFlag;

    #region Başlatma

    public override void OnNetworkSpawn()
    {
        Debug.Log(
            $"[PC-LOG {NetworkObjectId}] OnNetworkSpawn çağrıldı. IsServer: {IsServer}, IsClient: {IsClient}, IsOwner: {IsOwner}");

        // NavMeshAgent'a SADECE SUNUCUDA ihtiyaç duyulur.
        if (IsServer)
        {
            Debug.Log($"[PC-LOG {NetworkObjectId}] SUNUCU tarafı: NavMeshAgent bileşeni alınıyor.");
            _navMeshAgent = GetComponent<NavMeshAgent>();
            if (!_navMeshAgent) Debug.LogError($"[PC-LOG {NetworkObjectId}] SUNUCU HATA: NavMeshAgent bulunamadı!");
        }
        else // Client ise, NavMeshAgent'ı devre dışı bırak.
        {
            Debug.Log($"[PC-LOG {NetworkObjectId}] CLIENT tarafı: NavMeshAgent devre dışı bırakılıyor.");
            GetComponent<NavMeshAgent>().enabled = false;
        }

        // Eğer geminin sahibi biz isek, client'a özel kontrolleri başlat.
        if (IsOwner)
        {
            Debug.Log($"[PC-LOG {NetworkObjectId}] Bu geminin SAHİBİ benim. Client kontrolleri başlatılıyor.");
            InitializeClientControls();
        }
        else
        {
            Debug.Log($"[PC-LOG {NetworkObjectId}] Bu geminin sahibi değilim.");
        }
    }

    private void InitializeClientControls()
    {
        Debug.Log($"[PC-LOG {NetworkObjectId}] InitializeClientControls çağrıldı.");
        _mainCamera = Camera.main;
        if (!_mainCamera) Debug.LogError($"[PC-LOG {NetworkObjectId}] HATA: Camera.main bulunamadı!");

        var currentEventSystem = EventSystem.current;
        var inputModuleName = currentEventSystem != null && currentEventSystem.currentInputModule != null
            ? currentEventSystem.currentInputModule.GetType().Name
            : "NULL";
        Debug.Log(
            $"[PC-LOG {NetworkObjectId}] EventSystem mevcut mu: {(currentEventSystem != null)} | ActiveInputModule: {inputModuleName}");
        Debug.Log($"[PC-LOG {NetworkObjectId}] Cursor.lockState={Cursor.lockState} visible={Cursor.visible}");
        Debug.Log(
            $"[PC-LOG {NetworkObjectId}] LayerMasks | movement={_movementLayerMask.value} target={_targetLayerMask.value}");

        OnLocalPlayerShipReady?.Invoke(transform);
        Debug.Log($"[PC-LOG {NetworkObjectId}] OnLocalPlayerShipReady olayı tetiklendi.");

        _playerInputActions = new PlayerInputActions();
        _playerInputActions.Player.Enable();
        _playerInputActions.Player.PrimaryClick.performed += HandlePrimaryClick;
        _playerInputActions.Player.Attack.performed += HandleAttack;
        Debug.Log($"[PC-LOG {NetworkObjectId}] Input Actions kuruldu ve olaylara abone olundu.");
    }

    public override void OnNetworkDespawn()
    {
        Debug.Log($"[PC-LOG {NetworkObjectId}] OnNetworkDespawn çağrıldı.");
        if (IsOwner && _playerInputActions != null)
        {
            Debug.Log($"[PC-LOG {NetworkObjectId}] Input olaylarından abonelikler iptal ediliyor.");
            _playerInputActions.Player.PrimaryClick.performed -= HandlePrimaryClick;
            _playerInputActions.Player.Attack.performed -= HandleAttack;
            _playerInputActions.Player.Disable();
        }
    }

    #endregion

    #region Input ve Komutlar

    private void HandlePrimaryClick(InputAction.CallbackContext context)
    {
        Debug.Log($"[PC-LOG {NetworkObjectId}] HandlePrimaryClick tetiklendi.");
        var hasEventSystem = EventSystem.current != null;
        bool pointerOver = hasEventSystem && EventSystem.current.IsPointerOverGameObject();

        if (!IsOwner || pointerOver)
        {
            Debug.LogWarning(
                $"[PC-LOG {NetworkObjectId}] HandlePrimaryClick durduruldu. IsOwner: {IsOwner}, HasEventSystem: {hasEventSystem}, IsPointerOverGameObject: {pointerOver}");

            if (pointerOver)
            {
                try
                {
                    var screenPositionDbg = _playerInputActions.Player.MousePosition.ReadValue<Vector2>();
                    var ped = new PointerEventData(EventSystem.current) { position = screenPositionDbg };
                    var raycastResults = new System.Collections.Generic.List<RaycastResult>();
                    EventSystem.current.RaycastAll(ped, raycastResults);
                    if (raycastResults.Count > 0)
                    {
                        var top = raycastResults[0];
                        Debug.LogWarning(
                            $"[PC-LOG {NetworkObjectId}] UI raycast tıklamayı blokluyor. Top={top.gameObject.name} | Module={top.module} | SortingOrder={top.sortingOrder}");
                    }
                    else
                    {
                        Debug.LogWarning(
                            $"[PC-LOG {NetworkObjectId}] IsPointerOverGameObject=true fakat RaycastAll sonuç yok.");
                    }
                }
                catch (Exception ex)
                {
                    Debug.LogWarning($"[PC-LOG {NetworkObjectId}] UI raycast debug sırasında hata: {ex.Message}");
                }
            }

            return;
        }

        var screenPosition = _playerInputActions.Player.MousePosition.ReadValue<Vector2>();
        var ray = _mainCamera.ScreenPointToRay(screenPosition);

        // ÖNCELİK 1: HEDEF SEÇME VE SALDIRI (MOBA Tarzı)
        if (Physics.Raycast(ray, out var hitTarget, 1000f, _targetLayerMask))
        {
            if (hitTarget.collider.TryGetComponent<Targetable>(out var newTarget) &&
                newTarget.gameObject != this.gameObject)
            {
                // 1. Hedefi Seç
                SetTarget(newTarget);

                // 2. Eğer bu bir düşmansa SALDIRI EMRİ VER (Eskiden '1' tuşuyla yapıyordun)
                // Not: İstersen bunu sağ tıka alabilirsin ama şimdilik "Tıkla ve Saldır" yapıyoruz.
                ulong targetId = newTarget.GetComponent<NetworkObject>().NetworkObjectId;
                RequestAttackToggleServerRpc(targetId);

                return; // Hareket etme, sadece saldırıya odaklan.
            }
        }

// ÖNCELİK 2: BOŞA TIKLANDI (HAREKET ET)
        if (Physics.Raycast(ray, out RaycastHit hitMovement, 1000f, _movementLayerMask))
        {
            // Boşa tıklayınca saldırıyı kes
            RequestAttackToggleServerRpc(ulong.MaxValue);

            if (_currentMoveFlag != null) Destroy(_currentMoveFlag);
            _currentMoveFlag = Instantiate(_moveFlagPrefab, hitMovement.point, Quaternion.identity);
            MoveToPositionServerRpc(hitMovement.point);
        }
    }

    private void HandleAttack(InputAction.CallbackContext context)
    {
        Debug.Log($"[PC-LOG {NetworkObjectId}] HandleAttack tetiklendi.");
        if (!IsOwner || CurrentTarget == null)
        {
            Debug.LogWarning(
                $"[PC-LOG {NetworkObjectId}] HandleAttack durduruldu. IsOwner: {IsOwner}, CurrentTarget: {(CurrentTarget == null ? "NULL" : CurrentTarget.name)}");
            return;
        }

        ulong targetId = CurrentTarget.GetComponent<NetworkObject>().NetworkObjectId;
        Debug.Log($"[PC-LOG {NetworkObjectId}] Sunucuya saldırı komutu gönderiliyor. Hedef ID: {targetId}");
        RequestAttackToggleServerRpc(targetId);
    }

    private void SetTarget(Targetable newTarget)
    {
        if (newTarget == CurrentTarget) return;
        Debug.Log($"[PC-LOG {NetworkObjectId}] Yeni hedef ayarlandı: {(newTarget == null ? "NULL" : newTarget.name)}");
        CurrentTarget = newTarget;
        OnTargetChanged?.Invoke(CurrentTarget);
    }

    [ServerRpc]
    private void MoveToPositionServerRpc(Vector3 destination)
    {
        Debug.Log($"[PC-LOG {NetworkObjectId}] SUNUCU: MoveToPositionServerRpc alındı. Hedef: {destination}");
        if (_navMeshAgent == null)
        {
            Debug.LogError($"[PC-LOG {NetworkObjectId}] SUNUCU HATA: _navMeshAgent DEĞİŞKENİ BOŞ (NULL)!");
            return;
        }

        Debug.Log(
            $"[PC-LOG {NetworkObjectId}] SUNUCU: NavMeshAgent'ın isOnNavMesh durumu: {_navMeshAgent.isOnNavMesh}");
        if (_navMeshAgent.isOnNavMesh)
        {
            Debug.Log($"[PC-LOG {NetworkObjectId}] SUNUCU: SetDestination çağrılıyor.");
            _navMeshAgent.SetDestination(destination);
        }
        else
        {
            Debug.LogWarning(
                $"[PC-LOG {NetworkObjectId}] SUNUCU UYARI: Gemi bir NavMesh üzerinde değil, hareket komutu yoksayılıyor.");
        }
    }

    [ServerRpc]
    private void RequestAttackToggleServerRpc(ulong targetId)
    {
        Debug.Log($"[PC-LOG {NetworkObjectId}] SUNUCU: RequestAttackToggleServerRpc alındı. Hedef ID: {targetId}");
        if (TryGetComponent<ShipCombat>(out var combat))
        {
            combat.ToggleAutoAttack(targetId);
        }
    }

    #endregion
}
</file>

<file path="Assets/_Project/Scripts/PlayerInfo.cs">
// Filename: PlayerInfo.cs

using TMPro;
using Unity.Netcode;
using Unity.Collections;
using UnityEngine;

public class PlayerInfo : NetworkBehaviour
{
    // Oyuncunun adını tüm client'lara senkronize et.
    public NetworkVariable<FixedString64Bytes> Username = new NetworkVariable<FixedString64Bytes>();
    
    // Gelecekte oyuncu seviyesi, loncası gibi bilgiler de buraya eklenebilir.
    // public NetworkVariable<int> PlayerLevel = new NetworkVariable<int>();

    [SerializeField] private TextMeshProUGUI  _userNameTextGUI;
    /// <summary>
    /// Bu metot, gemi spawn olurken sunucudaki PlayerManager tarafından çağrılır.
    /// </summary>
    public void Initialize(string username)
    {
        // NetworkVariable'ı sadece sunucu değiştirebilir.
        if (IsServer)
        {
            Username.Value = username;
            _userNameTextGUI.text = username;
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/ShipStats.cs">
// Filename: ShipStats.cs (Final, Correct Initialization Logic)
using Unity.Netcode;
using UnityEngine;
using UnityEngine.AI;

[RequireComponent(typeof(NavMeshAgent))]
public class ShipStats : NetworkBehaviour
{
    private NavMeshAgent _navMeshAgent;

    public NetworkVariable<float> Speed = new();
    public NetworkVariable<float> AngularSpeed = new();
    public NetworkVariable<float> HitRate = new();
    public NetworkVariable<float> Range = new();
    public NetworkVariable<float> Armor = new();
    public NetworkVariable<float> Cooldown = new();
    public int CurrentVigor { get; private set; }

    private void Awake()
    {
        _navMeshAgent = GetComponent<NavMeshAgent>();
    }

    public override void OnNetworkSpawn()
    {
        // OnValueChanged olayları, artık sadece oyun sırasında bir stat değişirse
        // (örn: bir buff veya debuff ile) çalışacak.
        if (IsServer)
        {
            Speed.OnValueChanged += OnSpeedChanged;
            AngularSpeed.OnValueChanged += OnAngularSpeedChanged;
        }
    }

    public override void OnNetworkDespawn()
    {
        if (IsServer)
        {
            Speed.OnValueChanged -= OnSpeedChanged;
            AngularSpeed.OnValueChanged -= OnAngularSpeedChanged;
        }
    }

    [ServerRpc(RequireOwnership = false)]
    public void InitializeServerRpc(ShipStatsData statsData)
    {
        // 1. NetworkVariable'lara API'den gelen ilk değerleri ata.
        Speed.Value = statsData.Speed;
        AngularSpeed.Value = statsData.Maneuverability;
        HitRate.Value = statsData.HitRate;
        Range.Value = statsData.Range;
        Armor.Value = statsData.Armor;
        Cooldown.Value = statsData.Cooldown;
        
        // --- KRİTİK DÜZELTME ---
        // 2. NavMeshAgent'ın başlangıç değerlerini, NetworkVariable'ların
        // OnValueChanged olayını beklemeden, DOĞRUDAN burada ata.
        if (IsServer && _navMeshAgent != null)
        {
            _navMeshAgent.speed = statsData.Speed;
            _navMeshAgent.angularSpeed = statsData.Maneuverability;
            Debug.Log($"[ShipStats] SUNUCU: NavMeshAgent doğrudan initialize edildi. Hız: {_navMeshAgent.speed}");
        }

        // 3. Sadece sahibinin bilmesi gereken Vigor değeri için RPC gönder.
        ClientRpcParams ownerParams = new ClientRpcParams
        {
            Send = new ClientRpcSendParams { TargetClientIds = new ulong[] { OwnerClientId } }
        };
        UpdateVigorClientRpc(statsData.CurrentVigor, ownerParams);
    }
    
    [ClientRpc]
    private void UpdateVigorClientRpc(int newVigor, ClientRpcParams clientRpcParams = default)
    {
        this.CurrentVigor = newVigor;
    }

    // Bu metotlar artık sadece oyun sırasında statlar değişirse çalışacak.
    private void OnSpeedChanged(float previousValue, float newValue)
    {
        if (IsServer && _navMeshAgent != null)
        {
            _navMeshAgent.speed = newValue;
        }
    }

    private void OnAngularSpeedChanged(float previousValue, float newValue)
    {
        if (IsServer && _navMeshAgent != null)
        {
            _navMeshAgent.angularSpeed = newValue;
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/UI/CannonballListItem.cs">
// Filename: CannonballListItem.cs - Prefab'ın üzerine eklenecek.
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using System;
using BarbarosKs.Shared.DTOs;
using UnityEngine.EventSystems;

public class CannonballListItem : MonoBehaviour, IPointerClickHandler
{
    [SerializeField] private Image _iconImage;
    [SerializeField] private TMP_Text _nameText;
    [SerializeField] private TMP_Text _descriptionText;
    [SerializeField] private TMP_Text _quantityText;
    [SerializeField] private Image _selectionFrame; // Seçildiğinde görünecek çerçeve

    public CannonballDto _cannonballData;
    private Action<int> _onSingleClick;
    private Action<int> _onDoubleClick;

    public void Setup(CannonballDto data, int quantity, Action<int> onSingleClick, Action<int> onDoubleClick)
    {
        _cannonballData = data;
        _onSingleClick = onSingleClick;
        _onDoubleClick = onDoubleClick;

        _nameText.text = data.Name;
        _descriptionText.text = data.Description;
        _quantityText.text = $"x{quantity}";
        
        // Resources klasöründen ikonu kodla yüklüyoruz.
        _iconImage.sprite = Resources.Load<Sprite>($"Icons/Cannonballs/{data.IconName}");

        SetSelected(false);
    }

    public void SetSelected(bool isSelected)
    {
        _selectionFrame.enabled = isSelected;
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.clickCount == 2)
        {
            _onDoubleClick?.Invoke(_cannonballData.Code);
        }
        else
        {
            _onSingleClick?.Invoke(_cannonballData.Code);
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/UI/CannonballUIController.cs">
// Filename: CannonballUIController.cs (Final, Corrected Version)

using System.Collections.Generic;
using BarbarosKs.Shared.DTOs;
using Unity.Netcode;
using UnityEngine;
using UnityEngine.UI;
using TMPro; // TextMeshPro için

public class CannonballUIController : MonoBehaviour
{
    [Header("UI Referansları")] [SerializeField]
    private GameObject _panel;

    [SerializeField] private RectTransform _listContentArea;
    [SerializeField] private GameObject _listItemPrefab;
    [SerializeField] private Button _equipButton;
    [SerializeField] private Button _openInventoryButton; // Envanteri açacak ana buton
    [SerializeField] private Image _selectedCannonballIcon;

    // Servisler ve Referanslar
    private PlayerInventory _playerInventory;
    private GameDataService _gameDataService;
    private ShipCombat _localPlayerShipCombat;

    private int _selectedCannonballCode = 0;
    private List<CannonballListItem> _instantiatedItems = new List<CannonballListItem>();

    void Start()
    {
        // GameManager'ın var olmasını bekle
        if (GameManager.Instance == null)
        {
            Debug.LogError("GameManager bulunamadı! Sahnenin doğru kurulduğundan emin olun.");
            this.enabled = false; // Script'i devre dışı bırak.
            return;
        }

        _playerInventory = ServiceLocator.Current.Get<PlayerInventory>();
        _gameDataService = ServiceLocator.Current.Get<GameDataService>();

        PlayerController.OnLocalPlayerShipReady += OnLocalPlayerReady;
        _equipButton.onClick.AddListener(OnEquipButtonClicked);
        _openInventoryButton.onClick.AddListener(TogglePanel);
        _panel.SetActive(false);
    }

    private void OnLocalPlayerReady(Transform playerTransform)
    {
        _localPlayerShipCombat = playerTransform.GetComponent<ShipCombat>();
        if (_localPlayerShipCombat)
        {
            _localPlayerShipCombat.EquippedCannonballCode.OnValueChanged += OnEquippedCannonballChanged;
            UpdateSelectedIcon(_localPlayerShipCombat.EquippedCannonballCode.Value);
        }
    }

    public void TogglePanel()
    {
        bool isActive = !_panel.activeSelf;
        _panel.SetActive(isActive);

        if (isActive)
        {
            RefreshList();
        }
    }

    private void RefreshList()
    {
        foreach (Transform child in _listContentArea)
        {
            Destroy(child.gameObject);
        }

        _instantiatedItems.Clear();

        if (_playerInventory == null || _gameDataService == null) return;

        foreach (var inventoryItem in _playerInventory.CannonballQuantities)
        {
            int code = inventoryItem.Key;
            int quantity = inventoryItem.Value;

            if (quantity <= 0) continue;

            CannonballDto cannonballStats = _gameDataService.GetCannonballStatsByCode(code);
            if (cannonballStats == null) continue;

            GameObject itemGO = Instantiate(_listItemPrefab, _listContentArea);
            var itemScript = itemGO.GetComponent<CannonballListItem>();
            // DTO'daki doğru alan adlarını kullandığımızdan emin olalım
            itemScript.Setup(cannonballStats, quantity, HandleSingleClick, HandleDoubleClick);
            _instantiatedItems.Add(itemScript);
        }

        if (_localPlayerShipCombat != null)
        {
            UpdateSelectionVisuals(_localPlayerShipCombat.EquippedCannonballCode.Value);
        }
    }

    private void HandleSingleClick(int code)
    {
        _selectedCannonballCode = code;
        _equipButton.interactable = true;
        UpdateSelectionVisuals(code);
    }

    private void HandleDoubleClick(int code)
    {
        _selectedCannonballCode = code;
        EquipSelectedCannonball();
    }

    private void OnEquipButtonClicked()
    {
        EquipSelectedCannonball();
    }

    private void EquipSelectedCannonball()
    {
        if (_selectedCannonballCode == 0 || _localPlayerShipCombat == null) return;

        _localPlayerShipCombat.EquipCannonballServerRpc(_selectedCannonballCode);
        TogglePanel(); // Paneli kapat
    }

    private void OnEquippedCannonballChanged(int previousCode, int newCode)
    {
        UpdateSelectedIcon(newCode);
        if (_panel.activeSelf)
        {
            UpdateSelectionVisuals(newCode);
        }
    }
    
    private void UpdateSelectedIcon(int cannonballCode)
    {
        var cannonballStats = _gameDataService?.GetCannonballStatsByCode(cannonballCode);
        if (cannonballStats != null)
        {
            _selectedCannonballIcon.sprite = Resources.Load<Sprite>($"Icons/Cannonballs/{cannonballStats.IconName}");
        }
    }

    private void UpdateSelectionVisuals(int selectedCode)
    {
        foreach (var item in _instantiatedItems)
        {
            // cannonballCode'un CannonballListItem'de public olduğunu varsayıyoruz.
            item.SetSelected(item._cannonballData.Code == selectedCode);
        }
    }

    private void OnDestroy()
    {
        // --- DÜZELTME BURADA ---
        // Artık null kontrolü yapmıyoruz, doğrudan abonelikten çıkıyoruz.
        PlayerController.OnLocalPlayerShipReady -= OnLocalPlayerReady;

        if (_localPlayerShipCombat != null)
        {
            _localPlayerShipCombat.EquippedCannonballCode.OnValueChanged -= OnEquippedCannonballChanged;
        }
    }
}
</file>

<file path="Assets/_Project/Settings/PlayerInputActions.cs">
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was auto-generated by com.unity.inputsystem:InputActionCodeGenerator
//     version 1.14.2
//     from Assets/_Project/Settings/PlayerInputActions.inputactions
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

/// <summary>
/// Provides programmatic access to <see cref="InputActionAsset" />, <see cref="InputActionMap" />, <see cref="InputAction" /> and <see cref="InputControlScheme" /> instances defined in asset "Assets/_Project/Settings/PlayerInputActions.inputactions".
/// </summary>
/// <remarks>
/// This class is source generated and any manual edits will be discarded if the associated asset is reimported or modified.
/// </remarks>
/// <example>
/// <code>
/// using namespace UnityEngine;
/// using UnityEngine.InputSystem;
///
/// // Example of using an InputActionMap named "Player" from a UnityEngine.MonoBehaviour implementing callback interface.
/// public class Example : MonoBehaviour, MyActions.IPlayerActions
/// {
///     private MyActions_Actions m_Actions;                  // Source code representation of asset.
///     private MyActions_Actions.PlayerActions m_Player;     // Source code representation of action map.
///
///     void Awake()
///     {
///         m_Actions = new MyActions_Actions();              // Create asset object.
///         m_Player = m_Actions.Player;                      // Extract action map object.
///         m_Player.AddCallbacks(this);                      // Register callback interface IPlayerActions.
///     }
///
///     void OnDestroy()
///     {
///         m_Actions.Dispose();                              // Destroy asset object.
///     }
///
///     void OnEnable()
///     {
///         m_Player.Enable();                                // Enable all actions within map.
///     }
///
///     void OnDisable()
///     {
///         m_Player.Disable();                               // Disable all actions within map.
///     }
///
///     #region Interface implementation of MyActions.IPlayerActions
///
///     // Invoked when "Move" action is either started, performed or canceled.
///     public void OnMove(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnMove: {context.ReadValue&lt;Vector2&gt;()}");
///     }
///
///     // Invoked when "Attack" action is either started, performed or canceled.
///     public void OnAttack(InputAction.CallbackContext context)
///     {
///         Debug.Log($"OnAttack: {context.ReadValue&lt;float&gt;()}");
///     }
///
///     #endregion
/// }
/// </code>
/// </example>
public partial class @PlayerInputActions: IInputActionCollection2, IDisposable
{
    /// <summary>
    /// Provides access to the underlying asset instance.
    /// </summary>
    public InputActionAsset asset { get; }

    /// <summary>
    /// Constructs a new instance.
    /// </summary>
    public @PlayerInputActions()
    {
        asset = InputActionAsset.FromJson(@"{
    ""version"": 1,
    ""name"": ""PlayerInputActions"",
    ""maps"": [
        {
            ""name"": ""Player"",
            ""id"": ""3d639d6d-140f-4678-80f0-05fb130a53bc"",
            ""actions"": [
                {
                    ""name"": ""MousePosition"",
                    ""type"": ""Value"",
                    ""id"": ""c5d0656b-ad1f-4a39-a2dc-a313aaf0ee28"",
                    ""expectedControlType"": ""Vector2"",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": true
                },
                {
                    ""name"": ""PrimaryClick"",
                    ""type"": ""Button"",
                    ""id"": ""e1802615-130e-4e10-a4ff-fb8a3348b20f"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""Attack"",
                    ""type"": ""Button"",
                    ""id"": ""2056ef93-7465-4b35-94f7-6d33adc2e132"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                },
                {
                    ""name"": ""TestMove"",
                    ""type"": ""Button"",
                    ""id"": ""7284d5d4-ae2c-4d13-9a21-6bf47e9fbe1a"",
                    ""expectedControlType"": """",
                    ""processors"": """",
                    ""interactions"": """",
                    ""initialStateCheck"": false
                }
            ],
            ""bindings"": [
                {
                    ""name"": """",
                    ""id"": ""ab84b5d6-0d4d-4f14-bb55-5b75c1834937"",
                    ""path"": ""<Mouse>/position"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""MousePosition"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""75c74d4f-e640-4acb-9554-3ae65732d9f3"",
                    ""path"": ""<Mouse>/leftButton"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""PrimaryClick"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""e125d410-9fa1-4d76-83aa-92da7944f175"",
                    ""path"": ""<Keyboard>/1"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""Attack"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                },
                {
                    ""name"": """",
                    ""id"": ""e9a2cc0f-e99c-4ae4-a596-b58abbd4144b"",
                    ""path"": ""<Keyboard>/t"",
                    ""interactions"": """",
                    ""processors"": """",
                    ""groups"": """",
                    ""action"": ""TestMove"",
                    ""isComposite"": false,
                    ""isPartOfComposite"": false
                }
            ]
        }
    ],
    ""controlSchemes"": []
}");
        // Player
        m_Player = asset.FindActionMap("Player", throwIfNotFound: true);
        m_Player_MousePosition = m_Player.FindAction("MousePosition", throwIfNotFound: true);
        m_Player_PrimaryClick = m_Player.FindAction("PrimaryClick", throwIfNotFound: true);
        m_Player_Attack = m_Player.FindAction("Attack", throwIfNotFound: true);
        m_Player_TestMove = m_Player.FindAction("TestMove", throwIfNotFound: true);
    }

    ~@PlayerInputActions()
    {
        UnityEngine.Debug.Assert(!m_Player.enabled, "This will cause a leak and performance issues, PlayerInputActions.Player.Disable() has not been called.");
    }

    /// <summary>
    /// Destroys this asset and all associated <see cref="InputAction"/> instances.
    /// </summary>
    public void Dispose()
    {
        UnityEngine.Object.Destroy(asset);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.bindingMask" />
    public InputBinding? bindingMask
    {
        get => asset.bindingMask;
        set => asset.bindingMask = value;
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.devices" />
    public ReadOnlyArray<InputDevice>? devices
    {
        get => asset.devices;
        set => asset.devices = value;
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.controlSchemes" />
    public ReadOnlyArray<InputControlScheme> controlSchemes => asset.controlSchemes;

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Contains(InputAction)" />
    public bool Contains(InputAction action)
    {
        return asset.Contains(action);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.GetEnumerator()" />
    public IEnumerator<InputAction> GetEnumerator()
    {
        return asset.GetEnumerator();
    }

    /// <inheritdoc cref="IEnumerable.GetEnumerator()" />
    IEnumerator IEnumerable.GetEnumerator()
    {
        return GetEnumerator();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Enable()" />
    public void Enable()
    {
        asset.Enable();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.Disable()" />
    public void Disable()
    {
        asset.Disable();
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.bindings" />
    public IEnumerable<InputBinding> bindings => asset.bindings;

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.FindAction(string, bool)" />
    public InputAction FindAction(string actionNameOrId, bool throwIfNotFound = false)
    {
        return asset.FindAction(actionNameOrId, throwIfNotFound);
    }

    /// <inheritdoc cref="UnityEngine.InputSystem.InputActionAsset.FindBinding(InputBinding, out InputAction)" />
    public int FindBinding(InputBinding bindingMask, out InputAction action)
    {
        return asset.FindBinding(bindingMask, out action);
    }

    // Player
    private readonly InputActionMap m_Player;
    private List<IPlayerActions> m_PlayerActionsCallbackInterfaces = new List<IPlayerActions>();
    private readonly InputAction m_Player_MousePosition;
    private readonly InputAction m_Player_PrimaryClick;
    private readonly InputAction m_Player_Attack;
    private readonly InputAction m_Player_TestMove;
    /// <summary>
    /// Provides access to input actions defined in input action map "Player".
    /// </summary>
    public struct PlayerActions
    {
        private @PlayerInputActions m_Wrapper;

        /// <summary>
        /// Construct a new instance of the input action map wrapper class.
        /// </summary>
        public PlayerActions(@PlayerInputActions wrapper) { m_Wrapper = wrapper; }
        /// <summary>
        /// Provides access to the underlying input action "Player/MousePosition".
        /// </summary>
        public InputAction @MousePosition => m_Wrapper.m_Player_MousePosition;
        /// <summary>
        /// Provides access to the underlying input action "Player/PrimaryClick".
        /// </summary>
        public InputAction @PrimaryClick => m_Wrapper.m_Player_PrimaryClick;
        /// <summary>
        /// Provides access to the underlying input action "Player/Attack".
        /// </summary>
        public InputAction @Attack => m_Wrapper.m_Player_Attack;
        /// <summary>
        /// Provides access to the underlying input action "Player/TestMove".
        /// </summary>
        public InputAction @TestMove => m_Wrapper.m_Player_TestMove;
        /// <summary>
        /// Provides access to the underlying input action map instance.
        /// </summary>
        public InputActionMap Get() { return m_Wrapper.m_Player; }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Enable()" />
        public void Enable() { Get().Enable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.Disable()" />
        public void Disable() { Get().Disable(); }
        /// <inheritdoc cref="UnityEngine.InputSystem.InputActionMap.enabled" />
        public bool enabled => Get().enabled;
        /// <summary>
        /// Implicitly converts an <see ref="PlayerActions" /> to an <see ref="InputActionMap" /> instance.
        /// </summary>
        public static implicit operator InputActionMap(PlayerActions set) { return set.Get(); }
        /// <summary>
        /// Adds <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <param name="instance">Callback instance.</param>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c> or <paramref name="instance"/> have already been added this method does nothing.
        /// </remarks>
        /// <seealso cref="PlayerActions" />
        public void AddCallbacks(IPlayerActions instance)
        {
            if (instance == null || m_Wrapper.m_PlayerActionsCallbackInterfaces.Contains(instance)) return;
            m_Wrapper.m_PlayerActionsCallbackInterfaces.Add(instance);
            @MousePosition.started += instance.OnMousePosition;
            @MousePosition.performed += instance.OnMousePosition;
            @MousePosition.canceled += instance.OnMousePosition;
            @PrimaryClick.started += instance.OnPrimaryClick;
            @PrimaryClick.performed += instance.OnPrimaryClick;
            @PrimaryClick.canceled += instance.OnPrimaryClick;
            @Attack.started += instance.OnAttack;
            @Attack.performed += instance.OnAttack;
            @Attack.canceled += instance.OnAttack;
            @TestMove.started += instance.OnTestMove;
            @TestMove.performed += instance.OnTestMove;
            @TestMove.canceled += instance.OnTestMove;
        }

        /// <summary>
        /// Removes <see cref="InputAction.started"/>, <see cref="InputAction.performed"/> and <see cref="InputAction.canceled"/> callbacks provided via <param cref="instance" /> on all input actions contained in this map.
        /// </summary>
        /// <remarks>
        /// Calling this method when <paramref name="instance" /> have not previously been registered has no side-effects.
        /// </remarks>
        /// <seealso cref="PlayerActions" />
        private void UnregisterCallbacks(IPlayerActions instance)
        {
            @MousePosition.started -= instance.OnMousePosition;
            @MousePosition.performed -= instance.OnMousePosition;
            @MousePosition.canceled -= instance.OnMousePosition;
            @PrimaryClick.started -= instance.OnPrimaryClick;
            @PrimaryClick.performed -= instance.OnPrimaryClick;
            @PrimaryClick.canceled -= instance.OnPrimaryClick;
            @Attack.started -= instance.OnAttack;
            @Attack.performed -= instance.OnAttack;
            @Attack.canceled -= instance.OnAttack;
            @TestMove.started -= instance.OnTestMove;
            @TestMove.performed -= instance.OnTestMove;
            @TestMove.canceled -= instance.OnTestMove;
        }

        /// <summary>
        /// Unregisters <param cref="instance" /> and unregisters all input action callbacks via <see cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />.
        /// </summary>
        /// <seealso cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />
        public void RemoveCallbacks(IPlayerActions instance)
        {
            if (m_Wrapper.m_PlayerActionsCallbackInterfaces.Remove(instance))
                UnregisterCallbacks(instance);
        }

        /// <summary>
        /// Replaces all existing callback instances and previously registered input action callbacks associated with them with callbacks provided via <param cref="instance" />.
        /// </summary>
        /// <remarks>
        /// If <paramref name="instance" /> is <c>null</c>, calling this method will only unregister all existing callbacks but not register any new callbacks.
        /// </remarks>
        /// <seealso cref="PlayerActions.AddCallbacks(IPlayerActions)" />
        /// <seealso cref="PlayerActions.RemoveCallbacks(IPlayerActions)" />
        /// <seealso cref="PlayerActions.UnregisterCallbacks(IPlayerActions)" />
        public void SetCallbacks(IPlayerActions instance)
        {
            foreach (var item in m_Wrapper.m_PlayerActionsCallbackInterfaces)
                UnregisterCallbacks(item);
            m_Wrapper.m_PlayerActionsCallbackInterfaces.Clear();
            AddCallbacks(instance);
        }
    }
    /// <summary>
    /// Provides a new <see cref="PlayerActions" /> instance referencing this action map.
    /// </summary>
    public PlayerActions @Player => new PlayerActions(this);
    /// <summary>
    /// Interface to implement callback methods for all input action callbacks associated with input actions defined by "Player" which allows adding and removing callbacks.
    /// </summary>
    /// <seealso cref="PlayerActions.AddCallbacks(IPlayerActions)" />
    /// <seealso cref="PlayerActions.RemoveCallbacks(IPlayerActions)" />
    public interface IPlayerActions
    {
        /// <summary>
        /// Method invoked when associated input action "MousePosition" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnMousePosition(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "PrimaryClick" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnPrimaryClick(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "Attack" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnAttack(InputAction.CallbackContext context);
        /// <summary>
        /// Method invoked when associated input action "TestMove" is either <see cref="UnityEngine.InputSystem.InputAction.started" />, <see cref="UnityEngine.InputSystem.InputAction.performed" /> or <see cref="UnityEngine.InputSystem.InputAction.canceled" />.
        /// </summary>
        /// <seealso cref="UnityEngine.InputSystem.InputAction.started" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.performed" />
        /// <seealso cref="UnityEngine.InputSystem.InputAction.canceled" />
        void OnTestMove(InputAction.CallbackContext context);
    }
}
</file>

<file path="Assets/_Project/Scripts/Api/AuthApiService.cs">
// Filename: AuthApiService.cs

using System.Threading.Tasks;
using System;
using BarbarosKs.Shared.DTOs;

public class AuthApiService : BaseApiService, IGameService
{
    public event Action OnLoginSuccess;
    public event Action<string> OnLoginFailed;

    public async Task LoginAsync(string email, string password)
    {
        var requestData = new LoginRequest { email = email, password = password };
        var authResponse = await PostAsync<LoginRequest, AuthResponseDto>("api/auth/login", requestData, false);

        if (authResponse is { Success: true })
        {
            SetToken(authResponse.Token); // Token'ı temel sınıftaki static değişkene kaydet.
            OnLoginSuccess?.Invoke();
        }
        else
        {
            OnLoginFailed?.Invoke(authResponse?.Message ?? "Bilinmeyen bir giriş hatası.");
        }
    }

    public async Task<bool> CheckServerStatusAsync()
    {
        // Bu metot token gerektirmez.
        try
        {
            var response = await HttpClient.GetAsync("/api/auth/health");
            return response.IsSuccessStatusCode;
        }
        catch
        {
            return false;
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/Api/PlayerApiService.cs">
// Filename: PlayerApiService.cs

using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using BarbarosKs.Shared.DTOs;
using UnityEngine; // Hata verirse bu satırı silin

public class PlayerApiService : BaseApiService, IGameService
{
    public List<PlayerShipListDto> Ships { get; private set; }
    public PlayerSessionDto PlayerSession { get; private set; }
    public ShipStatsDto ShipStats { get; private set; }
    public ShipData ShipData { get; private set; }

    public event Action OnPlayerShipsReceived;
    public event Action OnPlayerShipsReceivedFailed;

    public event Action OnPlayerConnected;
    public event Action OnPlayerConnectFailed;


	public async Task ConnectRequestToServerForData(Guid shipId, string preferredRegion = null, string overrideToken = null)
	{
		var request = new ConnectionRequestDto
		{
			ShipId = shipId,
			PreferredRegion = preferredRegion
		};

		ApiResponse<ConnectionResponseDto> response;
		if (!string.IsNullOrEmpty(overrideToken))
		{
			// İstek başına token ile POST
			response = await PostAsync<ConnectionRequestDto, ApiResponse<ConnectionResponseDto>>(
				"/api/connection/request", request, true, overrideToken);
		}
		else
		{
			// Global token ile POST (Login sonrası SetToken çağrıldıysa)
			response = await PostAsync<ConnectionRequestDto, ApiResponse<ConnectionResponseDto>>(
				"/api/connection/request", request, true);
		}

		if (response is { Success: true })
		{
			var connectionResponse = response.Data;
			PlayerSession = connectionResponse.PlayerSession;
			ShipStats = connectionResponse.ShipStats;
			ShipData = connectionResponse.ShipData;
			OnPlayerConnected?.Invoke();
		}
		else
		{
			OnPlayerConnectFailed?.Invoke();
		}
	}

    // get all ships list for select
    public async Task GetMyShipsDataAsync()
    {
        var response = await GetAsync<ApiResponse<List<PlayerShipListDto>>>("/api/players/me/ships");
        var shipList = response?.Data;
        if (shipList != null)
        {
            Debug.Log($"GetMyShipsDataAsync {shipList.Count}");
            Ships = shipList;
            OnPlayerShipsReceived?.Invoke();
        }
        else
        {
            OnPlayerShipsReceivedFailed?.Invoke();
        }
    }

    public async Task<AttackResponseDto> ProcessAttackAsync(Guid attackerId, Guid targetId)
    {
        var payload = new AttackRequestDto
        {
            AttackerShipId = attackerId,
            TargetShipId = targetId
        };
        return await PostAsync<AttackRequestDto, AttackResponseDto>("/api/gateway/attack", payload);
    }

    public async Task<ShipRespawnResultDto> RespawnShipAsync(Guid shipId)
    {
        var endpoint = $"/api/players/ships/{shipId}/respawn";
        // JWT gerekli varsayımıyla default requireAuth=true kullanılacak
        return await PostAsync<object, ShipRespawnResultDto>(endpoint, new { });
    }


    // seçilen geminin özelliklerini getirir ama server için değil clientte görmesi için token gerekli
    public async Task<ShipDetailResponse> GetShipDetailAsync(Guid shipId)
    {
        // Yeni ve güvenli sunucu endpoint'ini çağırıyoruz.
        var endpoint = $"/api/players/ships/{shipId}/details";

        // Artık JWT Token kontrolü yapmayan GetAsync'i çağırabiliriz.
        // BaseApiService'teki GetAsync'ten 'requireAuth' kontrolünü kaldırabilir veya false geçebilirsiniz.
        return await GetAsync<ShipDetailResponse>(endpoint);
    }

    public async Task<ShipDetailDto> CreateShipAsync(CreateShipRequestDto createShipDto)
    {
        var endpoint = $"/api/players/ships/create";

        return await PostAsync<CreateShipRequestDto, ShipDetailDto>(endpoint, createShipDto);
    }

    /// <summary>
    /// Sets the currently active cannonball for a ship by making a PUT request to the API.
    /// </summary>
    /// <param name="shipId">The unique ID of the ship.</param>
    /// <param name="cannonballCode">The unique 'Code' of the cannonball to activate.</param>
    /// <returns>True if the operation was successful, false otherwise.</returns>
    public async Task<bool> SetActiveCannonball(Guid shipId, int cannonballCode)
    {
        // 1. Construct the correct endpoint URL.
        string endpoint = $"/api/Cannonball/ship/{shipId}/active";

        // 2. Create the request payload object.
        var requestPayload = new SetActiveCannonballRequestDto
        {
            CannonballCode = cannonballCode
        };

        // 3. Call the generic PutAsync method from BaseApiService.
        // It sends the payload and expects a generic ApiResponseDto back.
        var response = await PutAsync<SetActiveCannonballRequestDto, ApiResponse>(endpoint, requestPayload);

        // 4. Return true if the response is not null and the API reported success.
        return response is { Success: true };
    }

    #region Connection methods

    // first connection and include stat
    public async Task<ConnectionResponseDto> ConnectToServer(ConnectionRequestDto request)
    {
        var endpoint = $"/api/connection/request";
        return await PostAsync<ConnectionRequestDto, ConnectionResponseDto>(endpoint, request, false);
    }

    public async Task<object> DisconnectFromServer(DisconnectRequestDto request)
    {
        var endpoint = $"/api/connection/disconnect";
        return await PostAsync<DisconnectRequestDto, object>(endpoint, request, false);
    }

    public async Task<List<ServerStatusDto>> GetServers()
    {
        var endpoint = $"/api/connection/servers";
        return await GetAsync<List<ServerStatusDto>>(endpoint, false);
    }

    #endregion
}
</file>

<file path="Assets/_Project/Scripts/Core/PlayerManager.cs">
// Filename: PlayerManager.cs (Final Simplified Version)

using System;
using BarbarosKs.Shared.DTOs;
using Unity.Netcode;
using UnityEngine;
using Unity.Collections;

// Bu script artık bir IGameService olmak zorunda değil.
public class PlayerManager : IGameService
{
    // Bu metot artık sadece GameManager tarafından çağrılıyor.
    public async void SpawnPlayer(ulong clientId, Guid shipIdToSpawn)
    {
        Debug.Log($"[SPAWN] SpawnPlayer çağrıldı | clientId={clientId} shipIdToSpawn={shipIdToSpawn}");
        var playerApiService = ServiceLocator.Current.Get<PlayerApiService>();
        if (playerApiService == null)
        {
            Debug.LogError("[SPAWN] PlayerApiService ServiceLocator üzerinden alınamadı!");
            return;
        }

        Debug.Log("[SPAWN] PlayerApiService alındı, sunucuya bağlanılıyor...");
        await playerApiService.ConnectRequestToServerForData(shipIdToSpawn);
        Debug.Log("[SPAWN] Sunucudan gerekli veriler alındı (ConnectRequestToServerForData tamam)");
        var playerSession = playerApiService.PlayerSession;
        var shipData = playerApiService.ShipData;
        var shipStats = playerApiService.ShipStats;

        if (playerSession == null)
        {
            Debug.LogError("[SPAWN] playerSession null döndü!");
            return;
        }

        if (shipData == null)
        {
            Debug.LogError("[SPAWN] shipData null döndü!");
            return;
        }

        if (shipStats == null)
        {
            Debug.LogError("[SPAWN] shipStats null döndü!");
            return;
        }

        Debug.Log(
            $"[SPAWN] SessionShipId={playerSession.ShipId} | ShipName={shipData.ShipName} | Pos=({shipData.PositionX},{shipData.PositionY},{shipData.PositionZ}) | Rot=({shipData.RotationX},{shipData.RotationY},{shipData.RotationZ},{shipData.RotationW})");
        Debug.Log(
            $"[SPAWN] Stats | MaxHull={shipStats.MaxHull} CurrentHull={shipStats.CurrentHull} Speed={shipStats.Speed} Maneuverability={shipStats.Maneuverability} HitRate={shipStats.HitRate} Range={shipStats.Range} Armor={shipStats.Armor} CurrentVigor={shipStats.CurrentVigor}");
        // Debug.Log($"Veriler alındı: {shipData.ShipName}, Can: {shipDetail.CurrentHull}/{shipStats.MaxHull}");

        // Gemi pozisyonunu ve rotasyonunu sizin DTO'nuzdaki doğru alan adlarıyla alıyoruz.
        var spawnPosition = new Vector3(shipData.PositionX, shipData.PositionY, shipData.PositionZ);
        var spawnRotation = new Quaternion(shipData.RotationX, shipData.RotationY, shipData.RotationZ,
            shipData.RotationW);

        Debug.Log(
            $"[SPAWN] Instantiate başlıyor | Prefab={(GameManager.Instance && GameManager.Instance.ShipPrefab ? GameManager.Instance.ShipPrefab.name : "NULL")} | Pos={spawnPosition} Rot={spawnRotation}");
        var shipInstance = UnityEngine.Object.Instantiate(
            GameManager.Instance.ShipPrefab,
            spawnPosition,
            spawnRotation
        );
        Debug.Log($"[SPAWN] Instantiate tamam | Instance='{shipInstance.name}'");

        var networkObject = shipInstance.GetComponent<NetworkObject>();
        if (!networkObject)
        {
            Debug.LogError("[SPAWN] NetworkObject bileşeni gemi prefab'ında bulunamadı!");
            return;
        }

        networkObject.SpawnAsPlayerObject(clientId, true);
        Debug.Log("[SPAWN] NetworkObject.SpawnAsPlayerObject çağrıldı");
        Debug.Log("[DEBUG-9] Gemi bileşenleri verilerle dolduruluyor (Initialize)...");

        // NetworkVariable yazımlarını SPAWN'dan SONRA yap
        shipInstance.GetComponent<PlayerInfo>().Initialize(shipData.ShipName);
        Debug.Log($"[SPAWN] PlayerInfo.Initialize çağrıldı | ShipName='{shipData.ShipName}'");
        shipInstance.GetComponent<ShipIdentity>().shipId.Value =
            new FixedString128Bytes(playerSession.ShipId.ToString());
        Debug.Log($"[SPAWN] ShipIdentity.shipId atandı | {playerSession.ShipId}");
        shipInstance.GetComponent<Health>().Initialize(shipStats.MaxHull, shipStats.CurrentHull);
        Debug.Log(
            $"[SPAWN] Health.Initialize çağrıldı | MaxHull={shipStats.MaxHull} CurrentHull={shipStats.CurrentHull}");

        var playerController = shipInstance.GetComponent<PlayerController>();
        if (!playerController)
        {
            Debug.LogError("HATA: Gemi prefab'ının üzerinde PlayerController script'i bulunamadı!");
            return;
        }

        Debug.Log("[SPAWN] PlayerController bulundu");

        // yeni bir senkronizer data gelirse buraya ve shipStats ekelenecek
        var statsToSync = new ShipStatsData
        {
            Speed = shipStats.Speed,
            Maneuverability = shipStats.Maneuverability, // Manevra kabiliyetini doğrudan açısal hıza atıyoruz.
            HitRate = shipStats.HitRate,
            Range = shipStats.Range,
            Armor = shipStats.Armor,
            CurrentVigor = shipStats.CurrentVigor,
            Cooldown = shipStats.Cooldown,
        };
        Debug.Log(
            $"[SPAWN] ShipStatsData hazırlanıyor | Speed={statsToSync.Speed} Maneuverability={statsToSync.Maneuverability} HitRate={statsToSync.HitRate} Range={statsToSync.Range} Armor={statsToSync.Armor} CurrentVigor={statsToSync.CurrentVigor}");

        if (NetworkManager.Singleton.IsServer)
        {
            var sessionManager = ServiceLocator.Current.Get<ServerSessionManager>();

            sessionManager.RegisterSession(clientId, playerSession.ShipId, shipData.ShipName, shipStats.CurrentHull,
                shipStats.MaxHull, shipData.Cannonballs);
            ;
        }

        var shipStatsComponent = shipInstance.GetComponent<ShipStats>();
        if (!shipStatsComponent)
        {
            Debug.LogError("[SPAWN] ShipStats bileşeni gemi prefab'ında bulunamadı!");
            return;
        }

        shipStatsComponent.InitializeServerRpc(statsToSync);
        Debug.Log("[SPAWN] ShipStats.InitializeServerRpc çağrıldı");

        if (shipData.ActiveCannonballCode != null)
        {
            shipInstance.GetComponent<ShipCombat>().InitializeForPlayer(
                shipData.ActiveCannonballCode.Value,
                shipData.Cannonballs,
                playerController._cannonSpawnPoint // CannonSpawnPoint referansını PlayerController'dan alıyoruz.
            );
            Debug.Log(
                $"[SPAWN] ShipCombat.InitializeForPlayer çağrıldı | ActiveCannonball='{shipData.ActiveCannonballCode}' CannonballCount={(shipData.Cannonballs != null ? shipData.Cannonballs.Count : 0)} SpawnPointNull={(playerController._cannonSpawnPoint == null)}");
        }

        Debug.Log("[DEBUG-10] SpawnPlayer işlemi başarıyla tamamlandı.");
    }

    public async void ProcessAttack(ulong attackerId, ulong targetId)
    {
        // sunucu, saldıranın ve hedefin kimliğini bulur.
        if (!NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(targetId,
                out NetworkObject targetObject) ||
            !NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(attackerId,
                out NetworkObject attackerObject))
        {
            return;
        }

        var attackerIdentity = attackerObject.GetComponent<ShipIdentity>();
        var targetIdentity = targetObject.GetComponent<ShipIdentity>();

        if (attackerIdentity == null || targetIdentity == null) return;

        // Sunucu, ApıManager'ı kullanarak web api dan saldırı sonucunu sorar.
        var playerApiService = ServiceLocator.Current.Get<PlayerApiService>();
        AttackResponseDto result = await playerApiService.ProcessAttackAsync(
            new Guid(attackerIdentity.shipId.Value.ToString()),
            new Guid(targetIdentity.shipId.Value.ToString()));

        if (result == null) return;
        // web api dan gelen hasarı uygula
        if (!targetObject.TryGetComponent<Health>(out Health targetHealth)) return;
        Debug.Log($"API'den hasar sonucu geldi: {result.Damage}, Kritik: {result.IsCritical}. Uygulanıyor...");
        targetHealth.TakeDamage(result.Damage);
    }
}
</file>

<file path="Assets/_Project/Scripts/Data/ShipDetailResponse.cs">
// Filename: AuthResponse.cs

using BarbarosKs.Shared.DTOs;

[System.Serializable]
public class ShipDetailResponse
{
    public bool success;
    public string message;
    public ShipDetailDto Data;
    // playerData gibi diğer alanları şimdilik eklememize gerek yok.
}
</file>

<file path="Assets/_Project/Scripts/ShipCombat.cs">
// Filename: ShipCombat.cs (Final, Corrected Data Sync)

using System.Collections.Generic;
using BarbarosKs.Shared.DTOs;
using Unity.Netcode;
using UnityEngine;
using System;

public class ShipCombat : NetworkBehaviour
{
    public NetworkVariable<int> EquippedCannonballCode = new NetworkVariable<int>();

// Saldırı hızı kontrolü
    private float _lastAttackTime = -999f;

    // Otomatik saldırı hedefi
    private ulong _autoAttackTargetId = ulong.MaxValue;

    // Referanslar
    private ShipStats _shipStats;
    private Transform _cannonSpawnPoint;

    // RAM Yöneticisi Referansı
    private ServerSessionManager _sessionManager;

    public override void OnNetworkSpawn()
    {
        if (IsServer)
        {
            _shipStats = GetComponent<ShipStats>();
            // Performans için servisi cache'liyoruz
            _sessionManager = ServiceLocator.Current.Get<ServerSessionManager>();
        }
    }

    public void InitializeForPlayer(int activeCannonballCode, List<ShipCannonballInventoryDto> inventory,
        Transform cannonSpawnPoint)
    {
        if (!IsServer) return;

        EquippedCannonballCode.Value = activeCannonballCode;
        _cannonSpawnPoint = cannonSpawnPoint;

        // NOT: Envanter artık burada değil, ServerSessionManager'da (RAM) tutuluyor.
        // Client'ın UI güncellemesi için RPC gönderiyoruz.
        var inventoryWrapper = new ShipCannonballInventoryWrapper { Inventory = inventory };
        SyncInventoryClientRpc(inventoryWrapper,
            new ClientRpcParams { Send = new ClientRpcSendParams { TargetClientIds = new[] { OwnerClientId } } });
    }

    public void InitializeForNpc(int cannonballCode, Transform cannonSpawnPoint)
    {
        if (!IsServer) return;
        EquippedCannonballCode.Value = cannonballCode;
        _cannonSpawnPoint = cannonSpawnPoint;
    }

    /// <summary>
    /// Saldırı emri verir veya durdurur.
    /// </summary>
    public void ToggleAutoAttack(ulong targetId)
    {
        if (!IsServer) return;

        // Eğer aynı hedefe tekrar tıklandıysa veya geçersiz bir id geldiyse saldırıyı durdurma mantığı eklenebilir.
        // Şimdilik doğrudan hedefi güncelliyoruz.
        _autoAttackTargetId = targetId;

        // Hedef geçerli mi kontrol et, değilse saldırıyı iptal et
        if (!NetworkManager.Singleton.SpawnManager.SpawnedObjects.ContainsKey(targetId))
        {
            _autoAttackTargetId = ulong.MaxValue;
        }
    }

    private void Update()
    {
        // SADECE SUNUCU BU MANTIĞI ÇALIŞTIRIR
        if (!IsServer || _autoAttackTargetId == ulong.MaxValue) return;

        // 1. Hedef Oyunda mı?
        if (!NetworkManager.Singleton.SpawnManager.SpawnedObjects.TryGetValue(_autoAttackTargetId,
                out var targetObject))
        {
            _autoAttackTargetId = ulong.MaxValue; // Hedef yok oldu, saldırıyı kes
            return;
        }

        // 2. Cooldown Kontrolü
        if (Time.time < _lastAttackTime + _shipStats.Cooldown.Value) return;

        // 3. Menzil Kontrolü
        var gameDataService = ServiceLocator.Current.Get<GameDataService>();
        var ammoStats = gameDataService.GetCannonballStatsByCode(EquippedCannonballCode.Value);

        // Eğer veri servisinde bu gülle yoksa varsayılan bir menzil uydurmayalım, hata dönelim.
        if (ammoStats == null)
        {
            Debug.LogError($"[ShipCombat] Gülle verisi bulunamadı: {EquippedCannonballCode.Value}");
            return;
        }

        float totalRange = _shipStats.Range.Value + ammoStats.RangeBonus;
        if (Vector3.Distance(transform.position, targetObject.transform.position) > totalRange) return;

        // 4. SALDIRIYI GERÇEKLEŞTİR (RAM ÜZERİNDEN)
        ExecuteServerSideAttack(targetObject, ammoStats);
    }

    private void ExecuteServerSideAttack(NetworkObject targetObject, CannonballDto ammoStats)
    {
        // A. Mermi Kontrolü (RAM'den düş)
        // NPC mi Player mı kontrolü:
        bool isPlayer = _sessionManager.GetSession(OwnerClientId) != null;

        if (isPlayer)
        {
            var attackerSession = _sessionManager.GetSession(OwnerClientId);

            // Mermi var mı ve düşülebildi mi?
            if (!attackerSession.TryConsumeAmmo(ammoStats.Code, 1))
            {
                Debug.Log($"[Combat] Client {OwnerClientId} mermisi bitti! Saldırı durduruluyor.");
                _autoAttackTargetId = ulong.MaxValue;
                // Client'a "Mermi Bitti" uyarısı gönderilebilir (Todo)
                return;
            }

            // Client UI'ını güncelle (Gülle sayısı azaldı)
            UpdateClientAmmoUI(ammoStats.Code, attackerSession.Inventory[ammoStats.Code]);
        }

        // B. Saldırı Zamanını Güncelle
        _lastAttackTime = Time.time;

        // C. Hasar Hesapla (Basit Matematik - API YOK!)
        // Formül: (Gülle Hasarı) * Kritik Şans vb.
        int damage = ammoStats.BaseDamage;
        bool isCritical = UnityEngine.Random.value < 0.1f; // %10 Kritik şans
        if (isCritical) damage *= 2;

        // D. Hedefe Hasarı Uygula
        if (targetObject.TryGetComponent<Health>(out var targetHealth))
        {
            // Hedef bir oyuncuysa onun da RAM'deki verisini güncellemeliyiz!
            var targetSession = _sessionManager.GetSession(targetObject.OwnerClientId);
            if (targetSession != null)
            {
                targetSession.ApplyDamage(damage);
            }

            // NetworkVariable (Görsel Can) güncelle
            targetHealth.TakeDamage(damage);
        }

        // E. Görsel Efektler (Mermiyi oluştur)
        SpawnProjectileAndEffects(targetObject, damage, ammoStats.Code);
    }

    private void SpawnProjectileAndEffects(NetworkObject targetObject, int damage, int ammoCode)
    {
        var cannonballDb = GameManager.Instance.CannonballDatabase;
        var template = cannonballDb.GetCannonballByCode(ammoCode);
        if (template == null) return;

        // Muzzle Flash (Efekt - Tüm clientlarda oynar)
        FireEffectsClientRpc(ammoCode);

        // Mermiyi oluştur (Projectile)
        GameObject projectileInstance = Instantiate(template.projectilePrefab, _cannonSpawnPoint.position,
            _cannonSpawnPoint.rotation);
        projectileInstance.GetComponent<NetworkObject>().Spawn(); // Network'e tanıt

        // Mermiyi hedefe kilitle
        projectileInstance.GetComponent<CannonballProjectile>().Initialize(
            targetObject.NetworkObjectId,
            damage,
            20f, // Mermi hızı
            ammoCode
        );
    }

    [ClientRpc]
    private void UpdateSingleInventoryItemClientRpc(int code, int quantity, ClientRpcParams clientRpcParams = default)
    {
        var playerInventory = ServiceLocator.Current.Get<PlayerInventory>();
        // PlayerInventory içinde bu metodun olması lazım (Ekleyeceğiz)
        if (playerInventory is PlayerInventory inventory)
        {
            inventory.SetQuantity(code, quantity);
        }
    }

    private void UpdateClientAmmoUI(int ammoCode, int newQuantity)
    {
        UpdateSingleInventoryItemClientRpc(ammoCode, newQuantity, new ClientRpcParams
        {
            Send = new ClientRpcSendParams { TargetClientIds = new[] { OwnerClientId } }
        });
    }

    [ClientRpc]
    private void SyncInventoryClientRpc(ShipCannonballInventoryWrapper inventoryWrapper,
        ClientRpcParams clientRpcParams = default)
    {
        var playerInventory = ServiceLocator.Current.Get<PlayerInventory>();
        playerInventory.UpdateInventory(inventoryWrapper.Inventory);
    }

    [ClientRpc]
    private void FireEffectsClientRpc(int cannonballCode)
    {
        var cannonballDb = GameManager.Instance.CannonballDatabase;
        var template = cannonballDb.GetCannonballByCode(cannonballCode);
        if (template != null && template.muzzleFlashPrefab != null)
        {
            Instantiate(template.muzzleFlashPrefab, _cannonSpawnPoint.position, _cannonSpawnPoint.rotation);
        }
    }

    [ServerRpc]
    public void EquipCannonballServerRpc(int newCannonballCode)
    {
        // Envanter kontrolü RAM üzerinden yapılmalı
        var session = _sessionManager.GetSession(OwnerClientId);
        if (session != null && session.Inventory.TryGetValue(newCannonballCode, out int qty) && qty > 0)
        {
            EquippedCannonballCode.Value = newCannonballCode;
        }
    }
}

public struct ShipCannonballInventoryWrapper : INetworkSerializable
{
    public List<ShipCannonballInventoryDto> Inventory;

    public void NetworkSerialize<T>(BufferSerializer<T> serializer) where T : IReaderWriter
    {
        int count = 0;

        // Yazma modu (Server -> Client): Listede kaç eleman var belirle
        if (!serializer.IsReader && Inventory != null)
        {
            count = Inventory.Count;
        }

        // Eleman sayısını gönder/al
        serializer.SerializeValue(ref count);

        // Okuma modu (Client): Listeyi oluştur
        if (serializer.IsReader)
        {
            Inventory = new List<ShipCannonballInventoryDto>(count);
        }

        // Listenin her bir elemanını tek tek gönder/al
        for (int i = 0; i < count; i++)
        {
            // Varsayılan değerler
            int code = 0;
            int quantity = 0;

            // Yazma modu: Değerleri listeden al
            if (!serializer.IsReader)
            {
                code = Inventory[i].CannonballCode;
                quantity = Inventory[i].Quantity;
            }

            // Değerleri serileştir (Ağ üzerinden geçir)
            serializer.SerializeValue(ref code);
            serializer.SerializeValue(ref quantity);

            // Okuma modu: Okunan değerleri listeye ekle
            if (serializer.IsReader)
            {
                Inventory.Add(new ShipCannonballInventoryDto
                {
                    CannonballCode = code,
                    Quantity = quantity
                });
            }
        }
    }
}
</file>

<file path="Assets/_Project/Scripts/UI/MainMenuUIManager.cs">
// Filename: MainMenuUIManager.cs

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using Unity.Netcode;
using UnityEngine.SceneManagement;
using System.Collections.Generic;

// Bu yardımcı sınıfı script'in en altına veya ayrı bir dosyaya ekleyin.
[System.Serializable]
public class ConnectionPayload
{
    public string shipId; // GUID'i string olarak göndermek JSON için daha güvenilirdir.
}

public class MainMenuUIManager : MonoBehaviour
{
    [Header("Developer Settings")] [SerializeField]
    private bool _bypassServerCheck = false;

    [Header("Panels")] [SerializeField] private GameObject _loginPanel;
    [SerializeField] private GameObject _shipSelectionPanel;
    [SerializeField] private GameObject _loadingScreenPanel;

    [Header("Login UI")] [SerializeField] private TMP_InputField _emailInput;
    [SerializeField] private TMP_InputField _passwordInput;
    [SerializeField] private Button _loginButton;
    [SerializeField] private TMP_Text _statusText;

    [Header("Ship Selection UI")] [SerializeField]
    private RectTransform _shipListContent;

    private RectTransform _selectedShipData;

    [SerializeField] private GameObject _shipButtonPrefab;
    [SerializeField] private Button _launchButton;

    [Header("Loading Screen UI")] [SerializeField]
    private TMP_Text _loadingStatusText;

    [SerializeField] private TMP_Text _loadingTipText;
    [SerializeField] private string[] _gameTips;

    private AuthApiService _authApiService;
    private PlayerApiService _playerApiService;
    private GameSession _gameSession;

    private bool _networkSubscribed = false;


    private void Start()
    {
        _authApiService = ServiceLocator.Current.Get<AuthApiService>();
        _playerApiService = ServiceLocator.Current.Get<PlayerApiService>();
        _gameSession = ServiceLocator.Current.Get<GameSession>();

        _loginButton.onClick.AddListener(OnLoginClicked);
        _launchButton.onClick.AddListener(OnLaunchClicked);

        _authApiService.OnLoginSuccess += HandleLoginSuccess;
        _playerApiService.OnPlayerShipsReceived += HandlePlayerShipsReceived;

        _loginPanel.SetActive(true);
        _shipSelectionPanel.SetActive(false);
        _loadingScreenPanel.SetActive(false);
        _launchButton.interactable = false;
        _emailInput.text = "egoist@egoist.com";
        _passwordInput.text = "egoist";
    }

    // private void Update()
    // {
    //     if (_networkSubscribed || NetworkManager.Singleton == null)
    //     {
    //         return;
    //     }
    //     
    //     Debug.Log("MainMenuUIManager: NetworkManager hazır, olaylara abone olunuyor.");
    //     NetworkManager.Singleton.OnClientConnectedCallback += HandleClientConnected;
    //     NetworkManager.Singleton.OnClientDisconnectCallback += HandleClientDisconnected;
    //     _networkSubscribed = true;
    // }
    private void OnLoginClicked()
    {
        _statusText.text = "Giriş yapılıyor...";
        _loginButton.interactable = false;
        _ = _authApiService.LoginAsync(_emailInput.text, _passwordInput.text);
    }

    private void HandleLoginSuccess()
    {
        _statusText.text = "Karakter verileri alınıyor...";
        _ = _playerApiService.GetMyShipsDataAsync();
    }

    private void HandlePlayerShipsReceived()
    {
        _loginPanel.SetActive(false);
        _shipSelectionPanel.SetActive(true);
        PopulateShipList();
    }

    private void PopulateShipList()
    {
        foreach (Transform child in _shipListContent) Destroy(child.gameObject);

        foreach (var ship in _playerApiService.Ships)
        {
            var buttonGo = Instantiate(_shipButtonPrefab, _shipListContent);
            buttonGo.GetComponent<ShipSelectionButton>().Setup(ship, SelectShip);
        }
    }

    private void SelectShip(System.Guid shipId)
    {
        _gameSession.SelectedShipId = shipId;
        _launchButton.interactable = true;
        // _playerApiService.GetShipDetailAsync(shipId);
        // Debug.Log($"ship data: {JsonUtility.ToJson(_playerApiService.ShipStats)}");
        // var shipFeatures = Instantiate(_selectedShipData);
        Debug.Log($"Gemi seçildi: {shipId}");
    }

    private async void OnLaunchClicked()
    {
        if (_gameSession.SelectedShipId == System.Guid.Empty) return;

        // Panelleri ayarla ve yükleme ekranını göster
        _shipSelectionPanel.SetActive(false);
        _loadingScreenPanel.SetActive(true);
        _loadingTipText.text = _gameTips[Random.Range(0, _gameTips.Length)];

        // Geliştirici bypass'ı aktif mi?
        if (_bypassServerCheck)
        {
            Debug.LogWarning("Geliştirici modu: Sunucu durum kontrolü atlanıyor.");
            ConnectToGameServer();
            return;
        }

        // Sunucu durumunu kontrol et ve bağlan.
        _loadingStatusText.text = "Sunucu durumu kontrol ediliyor...";
        bool isServerOnline = await _authApiService.CheckServerStatusAsync();

        if (isServerOnline)
        {
            ConnectToGameServer();
        }
        else
        {
            HandleConnectionFailed("Oyun sunucusu şu an aktif değil veya yanıt vermiyor.");
        }
    }

    private void ConnectToGameServer()
    {
        _loadingStatusText.text = "Sunucuya bağlanılıyor...";

        var payload = new ConnectionPayload { shipId = _gameSession.SelectedShipId.ToString() };
        string payloadJson = JsonUtility.ToJson(payload);
        NetworkManager.Singleton.NetworkConfig.ConnectionData = System.Text.Encoding.UTF8.GetBytes(payloadJson);
#if UNITY_EDITOR
        NetworkManager.Singleton.StartHost();
#else
            NetworkManager.Singleton.StartClient();
#endif
    }

    // private void HandleClientConnected(ulong clientId)
    // {
    //     if (clientId == NetworkManager.Singleton.LocalClientId)
    //     {
    //         _loadingStatusText.text = "Dünya yükleniyor...";
    //         SceneManager.LoadScene("Main");
    //     }
    // }

    // Hem bağlantı kopması hem de başarısızlık durumları için ortak metot
    private void HandleConnectionFailed(string reason)
    {
        _loadingScreenPanel.SetActive(false);
        _loginPanel.SetActive(true);
        _loginButton.interactable = true;
        _statusText.text = reason; // Hata sebebini göster
    }

    // private void HandleClientDisconnected(ulong clientId)
    // {
    //     if (clientId == NetworkManager.Singleton.LocalClientId)
    //     {
    //         HandleConnectionFailed("Sunucu ile bağlantı koptu.");
    //     }
    // }


    private void OnDestroy()
    {
        // Bu script yok olduğunda olay aboneliklerini iptal et.
        if (_authApiService != null && _playerApiService != null)
        {
            _authApiService.OnLoginSuccess -= HandleLoginSuccess;
            _playerApiService.OnPlayerShipsReceived -= HandlePlayerShipsReceived;
        }

        // if (NetworkManager.Singleton != null)
        // {
        //     NetworkManager.Singleton.OnClientConnectedCallback -= HandleClientConnected;
        //     NetworkManager.Singleton.OnClientDisconnectCallback -= HandleClientDisconnected;
        // }
    }
}
</file>

<file path="Assets/_Project/Scripts/UI/PlayerHUDController.cs">
// Filename: PlayerHUDController.cs

using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.Serialization;

public class PlayerHUDController : MonoBehaviour
{
    [Header("Player Frame Components")] [SerializeField]
    private GameObject _playerFramePanel;

    [SerializeField] private Slider _playerHealthSlider;
    [SerializeField] private TextMeshProUGUI _playerHealthText;
    [SerializeField] private TextMeshProUGUI _playerCooldown;
    [SerializeField] private TextMeshProUGUI _playerCurrentVigor;
    [SerializeField] private TextMeshProUGUI _playerRange;

    private Health _localPlayerHealth;
    private ShipStats _localPlayerShipStats;

    private void Awake()
    {
        // Oyuncumuzun gemisi hazır olduğunda bu olayı dinle.
        PlayerController.OnLocalPlayerShipReady += OnLocalPlayerReady;
        _playerFramePanel.SetActive(false); // Başlangıçta paneli gizle.
    }

    private void OnDestroy()
    {
        PlayerController.OnLocalPlayerShipReady -= OnLocalPlayerReady;
        if (_localPlayerHealth != null)
        {
            // Abonelikleri iptal et
            _localPlayerHealth.CurrentHealth.OnValueChanged -= UpdateCurrentHealthUI;
            _localPlayerHealth.MaxHealth.OnValueChanged -= UpdateMaxHealthUI;
        }
    }

    private void OnLocalPlayerReady(Transform playerTransform)
    {
        _playerFramePanel.SetActive(true);
        _localPlayerHealth = playerTransform.GetComponent<Health>();
        _localPlayerShipStats = playerTransform.GetComponent<ShipStats>();


        if (!_localPlayerHealth) return;

        // Hem anlık can hem de maksimum can değeri değiştiğinde UI'ı güncellemek için abone ol.
        _localPlayerHealth.CurrentHealth.OnValueChanged += UpdateCurrentHealthUI;
        _localPlayerHealth.MaxHealth.OnValueChanged += UpdateMaxHealthUI;

        // UI'ı mevcut verilerle ilk kez doldur.
        UpdateMaxHealthUI(0, _localPlayerHealth.MaxHealth.Value);
        UpdateCurrentHealthUI(0, _localPlayerHealth.CurrentHealth.Value);
        UpdateAttackRate(0, _localPlayerShipStats.Cooldown.Value);
        UpdateRange(0, _localPlayerShipStats.Range.Value);
        UpdateCurrentVigor(0, _localPlayerShipStats.CurrentVigor);
    }

    // Bu metot SADECE slider'ın maksimum değerini ayarlar.
    private void UpdateMaxHealthUI(int previousValue, int newValue)
    {
        _playerHealthSlider.maxValue = newValue;
    }

    // Bu metot SADECE slider'ın anlık değerini ve metni günceller.
    private void UpdateCurrentHealthUI(int previousValue, int newValue)
    {
        // DÜZELTME: NetworkVariable'ın içindeki değere .Value ile erişiyoruz.
        _playerHealthSlider.value = newValue;
        _playerHealthText.text = $"{newValue} / {_localPlayerHealth.MaxHealth.Value}";
    }

    private void UpdateAttackRate(int previousValue, float newValue)
    {
        _playerCooldown.text = newValue.ToString();
    }

    private void UpdateRange(int previousValue, float newValue)
    {
        _playerRange.text = newValue.ToString();
    }

    private void UpdateCurrentVigor(int previousValue, int newValue)
    {
        _playerCurrentVigor.text = newValue.ToString();
    }
}
</file>

<file path="Assets/_Project/Scripts/UI/ShipSelectionButton.cs">
// Filename: ShipSelectionButton.cs

using System;
using BarbarosKs.Shared.DTOs;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ShipSelectionButton : MonoBehaviour
{
    [SerializeField] private TMP_Text _shipInfoText;
    [SerializeField] private Button _button;

    private Guid _shipId;
    private Action<Guid> _onClickCallback;
    private PlayerApiService _playerApiService;
    // Bu metot, ana UI yöneticimiz tarafından çağrılacak.

    private void Start()
    {
        _playerApiService = ServiceLocator.Current.Get<PlayerApiService>();
    }

    public void Setup(PlayerShipListDto shipData, Action<Guid> onClickCallback)
    {
        _shipId = shipData.ShipId;
        _onClickCallback = onClickCallback;
        _shipInfoText.text = $"{shipData.ShipName} <size=20>(Lv. {shipData.Level} {shipData.ShipType})</size>";
        _button.onClick.AddListener(OnButtonClicked);
    }

    private void OnButtonClicked()
    {
        // Butona tıklandığında, ana yöneticiye hangi geminin ID'sinin
        // seçildiğini bildiren callback'i çağır.
        _onClickCallback?.Invoke(_shipId);
    }
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_Bitmap-Custom-Atlas.shader">
Shader "TextMeshPro/Bitmap Custom Atlas" {

Properties {
	_MainTex		    ("Font Atlas", 2D) = "white" {}
	_FaceTex		    ("Font Texture", 2D) = "white" {}
	_FaceColor	        ("Text Color", Color) = (1,1,1,1)

	_VertexOffsetX	    ("Vertex OffsetX", float) = 0
	_VertexOffsetY	    ("Vertex OffsetY", float) = 0
	_MaskSoftnessX	    ("Mask SoftnessX", float) = 0
	_MaskSoftnessY	    ("Mask SoftnessY", float) = 0

	_ClipRect		    ("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
	_Padding		    ("Padding", float) = 0

	_StencilComp        ("Stencil Comparison", Float) = 8
	_Stencil            ("Stencil ID", Float) = 0
	_StencilOp          ("Stencil Operation", Float) = 0
	_StencilWriteMask   ("Stencil Write Mask", Float) = 255
	_StencilReadMask    ("Stencil Read Mask", Float) = 255

	_CullMode           ("Cull Mode", Float) = 0
	_ColorMask          ("Color Mask", Float) = 15
}

SubShader{

	Tags { "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }

	Stencil
	{
		Ref[_Stencil]
		Comp[_StencilComp]
		Pass[_StencilOp]
		ReadMask[_StencilReadMask]
		WriteMask[_StencilWriteMask]
	}


	Lighting Off
	Cull [_CullMode]
	ZTest [unity_GUIZTestMode]
	ZWrite Off
	Fog { Mode Off }
	Blend SrcAlpha OneMinusSrcAlpha
	ColorMask[_ColorMask]

	Pass {
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP


		#include "UnityCG.cginc"
		#include "UnityUI.cginc"

		struct appdata_t
		{
			float4 vertex		: POSITION;
			fixed4 color		: COLOR;
			float4 texcoord0	: TEXCOORD0;
			float2 texcoord1	: TEXCOORD1;
		};

		struct v2f
		{
			float4	vertex		: SV_POSITION;
			fixed4	color		: COLOR;
			float2	texcoord0	: TEXCOORD0;
			float2	texcoord1	: TEXCOORD1;
			float4	mask		: TEXCOORD2;
		};

		uniform	sampler2D 	_MainTex;
		uniform	sampler2D 	_FaceTex;
		uniform float4		_FaceTex_ST;
		uniform	fixed4		_FaceColor;

		uniform float		_VertexOffsetX;
		uniform float		_VertexOffsetY;
		uniform float4		_ClipRect;
		uniform float		_MaskSoftnessX;
		uniform float		_MaskSoftnessY;
		uniform float		_UIMaskSoftnessX;
        uniform float		_UIMaskSoftnessY;
        uniform int _UIVertexColorAlwaysGammaSpace;

		v2f vert (appdata_t v)
		{
			float4 vert = v.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;

			vert.xy += (vert.w * 0.5) / _ScreenParams.xy;

			float4 vPosition = UnityPixelSnap(UnityObjectToClipPos(vert));

            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                v.color.rgb = UIGammaToLinear(v.color.rgb);
            }
			fixed4 faceColor = v.color;
			faceColor *= _FaceColor;

			v2f OUT;
			OUT.vertex = vPosition;
			OUT.color = faceColor;
			OUT.texcoord0 = v.texcoord0;
			OUT.texcoord1 = TRANSFORM_TEX(v.texcoord1, _FaceTex);
			float2 pixelSize = vPosition.w;
			pixelSize /= abs(float2(_ScreenParams.x * UNITY_MATRIX_P[0][0], _ScreenParams.y * UNITY_MATRIX_P[1][1]));

			// Clamp _ClipRect to 16bit.
			const float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			OUT.mask = float4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));

			return OUT;
		}

		fixed4 frag (v2f IN) : SV_Target
		{
			fixed4 color = tex2D(_MainTex, IN.texcoord0) * tex2D(_FaceTex, IN.texcoord1) * IN.color;

			// Alternative implementation to UnityGet2DClipping with support for softness.
			#if UNITY_UI_CLIP_RECT
				half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(IN.mask.xy)) * IN.mask.zw);
				color *= m.x * m.y;
			#endif

			#if UNITY_UI_ALPHACLIP
				clip(color.a - 0.001);
			#endif

			return color;
		}
		ENDCG
	}
}

	CustomEditor "TMPro.EditorUtilities.TMP_BitmapShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_Bitmap-Mobile.shader">
Shader "TextMeshPro/Mobile/Bitmap" {

Properties {
	_MainTex		    ("Font Atlas", 2D) = "white" {}
	_Color		        ("Text Color", Color) = (1,1,1,1)
	_DiffusePower	    ("Diffuse Power", Range(1.0,4.0)) = 1.0

	_VertexOffsetX      ("Vertex OffsetX", float) = 0
	_VertexOffsetY      ("Vertex OffsetY", float) = 0
	_MaskSoftnessX      ("Mask SoftnessX", float) = 0
	_MaskSoftnessY      ("Mask SoftnessY", float) = 0

	_ClipRect           ("Clip Rect", vector) = (-32767, -32767, 32767, 32767)

	_StencilComp        ("Stencil Comparison", Float) = 8
	_Stencil            ("Stencil ID", Float) = 0
	_StencilOp          ("Stencil Operation", Float) = 0
	_StencilWriteMask   ("Stencil Write Mask", Float) = 255
	_StencilReadMask    ("Stencil Read Mask", Float) = 255

	_CullMode           ("Cull Mode", Float) = 0
	_ColorMask          ("Color Mask", Float) = 15
}

SubShader {

	Tags { "Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" }

	Stencil
	{
		Ref[_Stencil]
		Comp[_StencilComp]
		Pass[_StencilOp]
		ReadMask[_StencilReadMask]
		WriteMask[_StencilWriteMask]
	}


	Lighting Off
	Cull [_CullMode]
	ZTest [unity_GUIZTestMode]
	ZWrite Off
	Fog { Mode Off }
	Blend SrcAlpha OneMinusSrcAlpha
	ColorMask[_ColorMask]

	Pass {
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag
		#pragma fragmentoption ARB_precision_hint_fastest

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP


		#include "UnityCG.cginc"
		#include "UnityUI.cginc"

		struct appdata_t
		{
			float4 vertex : POSITION;
			fixed4 color : COLOR;
			float2 texcoord0 : TEXCOORD0;
			float2 texcoord1 : TEXCOORD1;
		};

		struct v2f
		{
			float4 vertex		: POSITION;
			fixed4 color		: COLOR;
			float2 texcoord0	: TEXCOORD0;
			float4 mask			: TEXCOORD2;
		};

		sampler2D 	_MainTex;
		fixed4		_Color;
		float		_DiffusePower;

		uniform float		_VertexOffsetX;
		uniform float		_VertexOffsetY;
		uniform float4		_ClipRect;
		uniform float		_MaskSoftnessX;
		uniform float		_MaskSoftnessY;
		uniform float		_UIMaskSoftnessX;
        uniform float		_UIMaskSoftnessY;
        uniform int _UIVertexColorAlwaysGammaSpace;

		v2f vert (appdata_t v)
		{
			v2f OUT;
			float4 vert = v.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;

			vert.xy += (vert.w * 0.5) / _ScreenParams.xy;
            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                v.color.rgb = UIGammaToLinear(v.color.rgb);
            }
            OUT.vertex = UnityPixelSnap(UnityObjectToClipPos(vert));
			OUT.color = v.color;
			OUT.color *= _Color;
			OUT.color.rgb *= _DiffusePower;
			OUT.texcoord0 = v.texcoord0;

			float2 pixelSize = OUT.vertex.w;
			//pixelSize /= abs(float2(_ScreenParams.x * UNITY_MATRIX_P[0][0], _ScreenParams.y * UNITY_MATRIX_P[1][1]));

			// Clamp _ClipRect to 16bit.
			const float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			OUT.mask = float4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));

			return OUT;
		}

		fixed4 frag (v2f IN) : COLOR
		{
			fixed4 color = fixed4(IN.color.rgb, IN.color.a * tex2D(_MainTex, IN.texcoord0).a);

			// Alternative implementation to UnityGet2DClipping with support for softness.
			#if UNITY_UI_CLIP_RECT
				half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(IN.mask.xy)) * IN.mask.zw);
				color *= m.x * m.y;
			#endif

			#if UNITY_UI_ALPHACLIP
				clip(color.a - 0.001);
			#endif

			return color;
		}
		ENDCG
	}
}

SubShader {
	Tags { "Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" }
	Lighting Off Cull Off ZTest Always ZWrite Off Fog { Mode Off }
	Blend SrcAlpha OneMinusSrcAlpha
	BindChannels {
		Bind "Color", color
		Bind "Vertex", vertex
		Bind "TexCoord", texcoord0
	}
	Pass {
		SetTexture [_MainTex] {
			constantColor [_Color] combine constant * primary, constant * texture
		}
	}
}

CustomEditor "TMPro.EditorUtilities.TMP_BitmapShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_Bitmap.shader">
Shader "TextMeshPro/Bitmap" {

Properties {
	_MainTex		    ("Font Atlas", 2D) = "white" {}
	_FaceTex		    ("Font Texture", 2D) = "white" {}
	_FaceColor	        ("Text Color", Color) = (1,1,1,1)

	_VertexOffsetX	    ("Vertex OffsetX", float) = 0
	_VertexOffsetY	    ("Vertex OffsetY", float) = 0
	_MaskSoftnessX	    ("Mask SoftnessX", float) = 0
	_MaskSoftnessY	    ("Mask SoftnessY", float) = 0

	_ClipRect           ("Clip Rect", vector) = (-32767, -32767, 32767, 32767)

	_StencilComp        ("Stencil Comparison", Float) = 8
	_Stencil            ("Stencil ID", Float) = 0
	_StencilOp          ("Stencil Operation", Float) = 0
	_StencilWriteMask   ("Stencil Write Mask", Float) = 255
	_StencilReadMask    ("Stencil Read Mask", Float) = 255

	_CullMode           ("Cull Mode", Float) = 0
	_ColorMask          ("Color Mask", Float) = 15
}

SubShader{

	Tags { "Queue" = "Transparent" "IgnoreProjector" = "True" "RenderType" = "Transparent" }

	Stencil
	{
		Ref[_Stencil]
		Comp[_StencilComp]
		Pass[_StencilOp]
		ReadMask[_StencilReadMask]
		WriteMask[_StencilWriteMask]
	}


	Lighting Off
	Cull [_CullMode]
	ZTest [unity_GUIZTestMode]
	ZWrite Off
	Fog { Mode Off }
	Blend SrcAlpha OneMinusSrcAlpha
	ColorMask[_ColorMask]

	Pass {
		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP


		#include "UnityCG.cginc"
		#include "UnityUI.cginc"

		struct appdata_t
		{
			float4 vertex		: POSITION;
			fixed4 color		: COLOR;
			float4 texcoord0	: TEXCOORD0;
			float2 texcoord1	: TEXCOORD1;
		};

		struct v2f
		{
			float4	vertex		: SV_POSITION;
			fixed4	color		: COLOR;
			float2	texcoord0	: TEXCOORD0;
			float2	texcoord1	: TEXCOORD1;
			float4	mask		: TEXCOORD2;
		};

		uniform	sampler2D 	_MainTex;
		uniform	sampler2D 	_FaceTex;
		uniform float4		_FaceTex_ST;
		uniform	fixed4		_FaceColor;

		uniform float		_VertexOffsetX;
		uniform float		_VertexOffsetY;
		uniform float4		_ClipRect;
		uniform float		_MaskSoftnessX;
		uniform float		_MaskSoftnessY;
		uniform float		_UIMaskSoftnessX;
        uniform float		_UIMaskSoftnessY;
        uniform int _UIVertexColorAlwaysGammaSpace;

		v2f vert (appdata_t v)
		{
			float4 vert = v.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;

			vert.xy += (vert.w * 0.5) / _ScreenParams.xy;

			float4 vPosition = UnityPixelSnap(UnityObjectToClipPos(vert));

            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                v.color.rgb = UIGammaToLinear(v.color.rgb);
            }
			fixed4 faceColor = v.color;
			faceColor *= _FaceColor;

			v2f OUT;
			OUT.vertex = vPosition;
			OUT.color = faceColor;
			OUT.texcoord0 = v.texcoord0;
			OUT.texcoord1 = TRANSFORM_TEX(v.texcoord1, _FaceTex);
			float2 pixelSize = vPosition.w;
			pixelSize /= abs(float2(_ScreenParams.x * UNITY_MATRIX_P[0][0], _ScreenParams.y * UNITY_MATRIX_P[1][1]));

			// Clamp _ClipRect to 16bit.
			const float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			OUT.mask = float4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));

			return OUT;
		}

		fixed4 frag (v2f IN) : SV_Target
		{
			fixed4 color = tex2D(_MainTex, IN.texcoord0);
			color = fixed4 (tex2D(_FaceTex, IN.texcoord1).rgb * IN.color.rgb, IN.color.a * color.a);

			// Alternative implementation to UnityGet2DClipping with support for softness.
			#if UNITY_UI_CLIP_RECT
				half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(IN.mask.xy)) * IN.mask.zw);
				color *= m.x * m.y;
			#endif

			#if UNITY_UI_ALPHACLIP
				clip(color.a - 0.001);
			#endif

			return color;
		}
		ENDCG
	}
}

	CustomEditor "TMPro.EditorUtilities.TMP_BitmapShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF Overlay.shader">
Shader "TextMeshPro/Distance Field Overlay" {

Properties {
	_FaceTex			("Face Texture", 2D) = "white" {}
	_FaceUVSpeedX		("Face UV Speed X", Range(-5, 5)) = 0.0
	_FaceUVSpeedY		("Face UV Speed Y", Range(-5, 5)) = 0.0
	_FaceColor		    ("Face Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineTex			("Outline Texture", 2D) = "white" {}
	_OutlineUVSpeedX	("Outline UV Speed X", Range(-5, 5)) = 0.0
	_OutlineUVSpeedY	("Outline UV Speed Y", Range(-5, 5)) = 0.0
	_OutlineWidth		("Outline Thickness", Range(0, 1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_Bevel				("Bevel", Range(0,1)) = 0.5
	_BevelOffset		("Bevel Offset", Range(-0.5,0.5)) = 0
	_BevelWidth			("Bevel Width", Range(-.5,0.5)) = 0
	_BevelClamp			("Bevel Clamp", Range(0,1)) = 0
	_BevelRoundness		("Bevel Roundness", Range(0,1)) = 0

	_LightAngle			("Light Angle", Range(0.0, 6.2831853)) = 3.1416
	_SpecularColor	    ("Specular", Color) = (1,1,1,1)
	_SpecularPower		("Specular", Range(0,4)) = 2.0
	_Reflectivity		("Reflectivity", Range(5.0,15.0)) = 10
	_Diffuse			("Diffuse", Range(0,1)) = 0.5
	_Ambient			("Ambient", Range(1,0)) = 0.5

	_BumpMap 			("Normal map", 2D) = "bump" {}
	_BumpOutline		("Bump Outline", Range(0,1)) = 0
	_BumpFace			("Bump Face", Range(0,1)) = 0

	_ReflectFaceColor	("Reflection Color", Color) = (0,0,0,1)
	_ReflectOutlineColor("Reflection Color", Color) = (0,0,0,1)
	_Cube 				("Reflection Cubemap", Cube) = "black" { /* TexGen CubeReflect */ }
	_EnvMatrixRotation	("Texture Rotation", vector) = (0, 0, 0, 0)


	_UnderlayColor	    ("Border Color", Color) = (0,0,0, 0.5)
	_UnderlayOffsetX	("Border OffsetX", Range(-1,1)) = 0
	_UnderlayOffsetY	("Border OffsetY", Range(-1,1)) = 0
	_UnderlayDilate		("Border Dilate", Range(-1,1)) = 0
	_UnderlaySoftness	("Border Softness", Range(0,1)) = 0

	_GlowColor		    ("Color", Color) = (0, 1, 0, 0.5)
	_GlowOffset			("Offset", Range(-1,1)) = 0
	_GlowInner			("Inner", Range(0,1)) = 0.05
	_GlowOuter			("Outer", Range(0,1)) = 0.05
	_GlowPower			("Falloff", Range(1, 0)) = 0.75

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = 0.5

	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5.0
	_ScaleX				("Scale X", float) = 1.0
	_ScaleY				("Scale Y", float) = 1.0
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_MaskCoord			("Mask Coordinates", vector) = (0, 0, 32767, 32767)
	_ClipRect			("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
	_MaskSoftnessX		("Mask SoftnessX", float) = 0
	_MaskSoftnessY		("Mask SoftnessY", float) = 0

	_StencilComp		("Stencil Comparison", Float) = 8
	_Stencil			("Stencil ID", Float) = 0
	_StencilOp			("Stencil Operation", Float) = 0
	_StencilWriteMask	("Stencil Write Mask", Float) = 255
	_StencilReadMask	("Stencil Read Mask", Float) = 255

	_CullMode			("Cull Mode", Float) = 0
	_ColorMask			("Color Mask", Float) = 15
}

SubShader {

	Tags
  {
		"Queue"="Overlay"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}

	Stencil
	{
		Ref [_Stencil]
		Comp [_StencilComp]
		Pass [_StencilOp]
		ReadMask [_StencilReadMask]
		WriteMask [_StencilWriteMask]
	}

	Cull [_CullMode]
	ZWrite Off
	Lighting Off
	Fog { Mode Off }
	ZTest Always
	Blend One OneMinusSrcAlpha
	ColorMask [_ColorMask]

	Pass {
		CGPROGRAM
		#pragma target 3.0
		#pragma vertex VertShader
		#pragma fragment PixShader
		#pragma shader_feature __ BEVEL_ON
		#pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER
		#pragma shader_feature __ GLOW_ON

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP

		#include "UnityCG.cginc"
		#include "UnityUI.cginc"
		#include "TMPro_Properties.cginc"
		#include "TMPro.cginc"

		struct vertex_t
		{
			UNITY_VERTEX_INPUT_INSTANCE_ID
			float4	position		: POSITION;
			float3	normal			: NORMAL;
			fixed4	color			: COLOR;
			float4	texcoord0		: TEXCOORD0;
			float2	texcoord1		: TEXCOORD1;
		};

		struct pixel_t
		{
			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
			float4	position		: SV_POSITION;
			fixed4	color			: COLOR;
			float2	atlas			: TEXCOORD0;		// Atlas
			float4	param			: TEXCOORD1;		// alphaClip, scale, bias, weight
			float4	mask			: TEXCOORD2;		// Position in object space(xy), pixel Size(zw)
			float3	viewDir			: TEXCOORD3;

		    #if (UNDERLAY_ON || UNDERLAY_INNER)
			float4	texcoord2		: TEXCOORD4;		// u,v, scale, bias
			fixed4	underlayColor	: COLOR1;
		    #endif

			float4 textures			: TEXCOORD5;
		};

		// Used by Unity internally to handle Texture Tiling and Offset.
		uniform float4	_FaceTex_ST;
		uniform float4	_OutlineTex_ST;
		uniform float	_UIMaskSoftnessX;
        uniform float	_UIMaskSoftnessY;
        uniform int     _UIVertexColorAlwaysGammaSpace;

		pixel_t VertShader(vertex_t input)
		{
			pixel_t output;

			UNITY_INITIALIZE_OUTPUT(pixel_t, output);
			UNITY_SETUP_INSTANCE_ID(input);
			UNITY_TRANSFER_INSTANCE_ID(input,output);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

			float bold = step(input.texcoord0.w, 0);

			float4 vert = input.position;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;

			float4 vPosition = UnityObjectToClipPos(vert);

			float2 pixelSize = vPosition.w;
			pixelSize /= float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));
			float scale = rsqrt(dot(pixelSize, pixelSize));
			scale *= abs(input.texcoord0.w) * _GradientScale * (_Sharpness + 1);
			if (UNITY_MATRIX_P[3][3] == 0) scale = lerp(abs(scale) * (1 - _PerspectiveFilter), scale, abs(dot(UnityObjectToWorldNormal(input.normal.xyz), normalize(WorldSpaceViewDir(vert)))));

			float weight = lerp(_WeightNormal, _WeightBold, bold) / 4.0;
			weight = (weight + _FaceDilate) * _ScaleRatioA * 0.5;

			float bias =(.5 - weight) + (.5 / scale);

			float alphaClip = (1.0 - _OutlineWidth*_ScaleRatioA - _OutlineSoftness*_ScaleRatioA);

		    #if GLOW_ON
			alphaClip = min(alphaClip, 1.0 - _GlowOffset * _ScaleRatioB - _GlowOuter * _ScaleRatioB);
		    #endif

			alphaClip = alphaClip / 2.0 - ( .5 / scale) - weight;

		    #if (UNDERLAY_ON || UNDERLAY_INNER)
			float4 underlayColor = _UnderlayColor;
			underlayColor.rgb *= underlayColor.a;

			float bScale = scale;
			bScale /= 1 + ((_UnderlaySoftness*_ScaleRatioC) * bScale);
			float bBias = (0.5 - weight) * bScale - 0.5 - ((_UnderlayDilate * _ScaleRatioC) * 0.5 * bScale);

			float x = -(_UnderlayOffsetX * _ScaleRatioC) * _GradientScale / _TextureWidth;
			float y = -(_UnderlayOffsetY * _ScaleRatioC) * _GradientScale / _TextureHeight;
			float2 bOffset = float2(x, y);
		    #endif

			// Generate UV for the Masking Texture
			float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			float2 maskUV = (vert.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);

			// Support for texture tiling and offset
			float2 textureUV = input.texcoord1;
			float2 faceUV = TRANSFORM_TEX(textureUV, _FaceTex);
			float2 outlineUV = TRANSFORM_TEX(textureUV, _OutlineTex);


            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                input.color.rgb = UIGammaToLinear(input.color.rgb);
            }
			output.position = vPosition;
			output.color = input.color;
			output.atlas =	input.texcoord0;
			output.param =	float4(alphaClip, scale, bias, weight);
			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			output.mask = half4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));
			output.viewDir =	mul((float3x3)_EnvMatrix, _WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, vert).xyz);
			#if (UNDERLAY_ON || UNDERLAY_INNER)
			output.texcoord2 = float4(input.texcoord0 + bOffset, bScale, bBias);
			output.underlayColor =	underlayColor;
			#endif
			output.textures = float4(faceUV, outlineUV);

			return output;
		}


		fixed4 PixShader(pixel_t input) : SV_Target
		{
			UNITY_SETUP_INSTANCE_ID(input);

			float c = tex2D(_MainTex, input.atlas).a;

		    #ifndef UNDERLAY_ON
			clip(c - input.param.x);
		    #endif

			float	scale	= input.param.y;
			float	bias	= input.param.z;
			float	weight	= input.param.w;
			float	sd = (bias - c) * scale;

			float outline = (_OutlineWidth * _ScaleRatioA) * scale;
			float softness = (_OutlineSoftness * _ScaleRatioA) * scale;

			half4 faceColor = _FaceColor;
			half4 outlineColor = _OutlineColor;

			faceColor.rgb *= input.color.rgb;

			faceColor *= tex2D(_FaceTex, input.textures.xy + float2(_FaceUVSpeedX, _FaceUVSpeedY) * _Time.y);
			outlineColor *= tex2D(_OutlineTex, input.textures.zw + float2(_OutlineUVSpeedX, _OutlineUVSpeedY) * _Time.y);

			faceColor = GetColor(sd, faceColor, outlineColor, outline, softness);

		    #if BEVEL_ON
			float3 dxy = float3(0.5 / _TextureWidth, 0.5 / _TextureHeight, 0);
			float3 n = GetSurfaceNormal(input.atlas, weight, dxy);

			float3 bump = UnpackNormal(tex2D(_BumpMap, input.textures.xy + float2(_FaceUVSpeedX, _FaceUVSpeedY) * _Time.y)).xyz;
			bump *= lerp(_BumpFace, _BumpOutline, saturate(sd + outline * 0.5));
			n = normalize(n- bump);

			float3 light = normalize(float3(sin(_LightAngle), cos(_LightAngle), -1.0));

			float3 col = GetSpecular(n, light);
			faceColor.rgb += col*faceColor.a;
			faceColor.rgb *= 1-(dot(n, light)*_Diffuse);
			faceColor.rgb *= lerp(_Ambient, 1, n.z*n.z);

			fixed4 reflcol = texCUBE(_Cube, reflect(input.viewDir, -n));
			faceColor.rgb += reflcol.rgb * lerp(_ReflectFaceColor.rgb, _ReflectOutlineColor.rgb, saturate(sd + outline * 0.5)) * faceColor.a;
		    #endif

		    #if UNDERLAY_ON
			float d = tex2D(_MainTex, input.texcoord2.xy).a * input.texcoord2.z;
			faceColor += input.underlayColor * saturate(d - input.texcoord2.w) * (1 - faceColor.a);
		    #endif

		    #if UNDERLAY_INNER
			float d = tex2D(_MainTex, input.texcoord2.xy).a * input.texcoord2.z;
			faceColor += input.underlayColor * (1 - saturate(d - input.texcoord2.w)) * saturate(1 - sd) * (1 - faceColor.a);
		    #endif

		    #if GLOW_ON
			float4 glowColor = GetGlowColor(sd, scale);
			faceColor.rgb += glowColor.rgb * glowColor.a;
		    #endif

		    // Alternative implementation to UnityGet2DClipping with support for softness.
		    #if UNITY_UI_CLIP_RECT
			half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(input.mask.xy)) * input.mask.zw);
			faceColor *= m.x * m.y;
		    #endif

		    #if UNITY_UI_ALPHACLIP
			clip(faceColor.a - 0.001);
		    #endif

			return faceColor * input.color.a;
		}
		ENDCG
	}
}

Fallback "TextMeshPro/Mobile/Distance Field"
CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF SSD.shader">
Shader "TextMeshPro/Distance Field SSD" {

Properties {
    _FaceTex            ("Face Texture", 2D) = "white" {}
    _FaceUVSpeedX       ("Face UV Speed X", Range(-5, 5)) = 0.0
    _FaceUVSpeedY       ("Face UV Speed Y", Range(-5, 5)) = 0.0
    _FaceColor          ("Face Color", Color) = (1,1,1,1)
    _FaceDilate         ("Face Dilate", Range(-1,1)) = 0

    _OutlineColor       ("Outline Color", Color) = (0,0,0,1)
    _OutlineTex         ("Outline Texture", 2D) = "white" {}
    _OutlineUVSpeedX    ("Outline UV Speed X", Range(-5, 5)) = 0.0
    _OutlineUVSpeedY    ("Outline UV Speed Y", Range(-5, 5)) = 0.0
    _OutlineWidth       ("Outline Thickness", Range(0, 1)) = 0
    _OutlineSoftness    ("Outline Softness", Range(0,1)) = 0

    _Bevel              ("Bevel", Range(0,1)) = 0.5
    _BevelOffset        ("Bevel Offset", Range(-0.5,0.5)) = 0
    _BevelWidth         ("Bevel Width", Range(-.5,0.5)) = 0
    _BevelClamp         ("Bevel Clamp", Range(0,1)) = 0
    _BevelRoundness     ("Bevel Roundness", Range(0,1)) = 0

    _LightAngle         ("Light Angle", Range(0.0, 6.2831853)) = 3.1416
    _SpecularColor      ("Specular", Color) = (1,1,1,1)
    _SpecularPower      ("Specular", Range(0,4)) = 2.0
    _Reflectivity       ("Reflectivity", Range(5.0,15.0)) = 10
    _Diffuse            ("Diffuse", Range(0,1)) = 0.5
    _Ambient            ("Ambient", Range(1,0)) = 0.5

    _BumpMap            ("Normal map", 2D) = "bump" {}
    _BumpOutline        ("Bump Outline", Range(0,1)) = 0
    _BumpFace           ("Bump Face", Range(0,1)) = 0

    _ReflectFaceColor   ("Reflection Color", Color) = (0,0,0,1)
    _ReflectOutlineColor("Reflection Color", Color) = (0,0,0,1)
    _Cube               ("Reflection Cubemap", Cube) = "black" { /* TexGen CubeReflect */ }
    _EnvMatrixRotation  ("Texture Rotation", vector) = (0, 0, 0, 0)


    _UnderlayColor      ("Border Color", Color) = (0,0,0, 0.5)
    _UnderlayOffsetX    ("Border OffsetX", Range(-1,1)) = 0
    _UnderlayOffsetY    ("Border OffsetY", Range(-1,1)) = 0
    _UnderlayDilate     ("Border Dilate", Range(-1,1)) = 0
    _UnderlaySoftness   ("Border Softness", Range(0,1)) = 0

    _GlowColor          ("Color", Color) = (0, 1, 0, 0.5)
    _GlowOffset         ("Offset", Range(-1,1)) = 0
    _GlowInner          ("Inner", Range(0,1)) = 0.05
    _GlowOuter          ("Outer", Range(0,1)) = 0.05
    _GlowPower          ("Falloff", Range(1, 0)) = 0.75

    _WeightNormal       ("Weight Normal", float) = 0
    _WeightBold         ("Weight Bold", float) = 0.5

    _ShaderFlags        ("Flags", float) = 0
    _ScaleRatioA        ("Scale RatioA", float) = 1
    _ScaleRatioB        ("Scale RatioB", float) = 1
    _ScaleRatioC        ("Scale RatioC", float) = 1

    _MainTex            ("Font Atlas", 2D) = "white" {}
    _TextureWidth       ("Texture Width", float) = 512
    _TextureHeight      ("Texture Height", float) = 512
    _GradientScale      ("Gradient Scale", float) = 5.0
    _ScaleX             ("Scale X", float) = 1.0
    _ScaleY             ("Scale Y", float) = 1.0
    _PerspectiveFilter  ("Perspective Correction", Range(0, 1)) = 0.875
    _Sharpness          ("Sharpness", Range(-1,1)) = 0

    _VertexOffsetX      ("Vertex OffsetX", float) = 0
    _VertexOffsetY      ("Vertex OffsetY", float) = 0

    _MaskCoord          ("Mask Coordinates", vector) = (0, 0, 32767, 32767)
    _ClipRect           ("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
    _MaskSoftnessX      ("Mask SoftnessX", float) = 0
    _MaskSoftnessY      ("Mask SoftnessY", float) = 0

    _StencilComp        ("Stencil Comparison", Float) = 8
    _Stencil            ("Stencil ID", Float) = 0
    _StencilOp          ("Stencil Operation", Float) = 0
    _StencilWriteMask   ("Stencil Write Mask", Float) = 255
    _StencilReadMask    ("Stencil Read Mask", Float) = 255

    _CullMode           ("Cull Mode", Float) = 0
    _ColorMask          ("Color Mask", Float) = 15
}

SubShader {
    Tags
    {
        "Queue" = "Transparent"
        "IgnoreProjector" = "True"
        "RenderType" = "Transparent"
    }

    Stencil
    {
        Ref[_Stencil]
        Comp[_StencilComp]
        Pass[_StencilOp]
        ReadMask[_StencilReadMask]
        WriteMask[_StencilWriteMask]
    }

    Cull[_CullMode]
    ZWrite Off
    Lighting Off
    Fog { Mode Off }
    ZTest[unity_GUIZTestMode]
    Blend One OneMinusSrcAlpha
    ColorMask[_ColorMask]

    Pass
    {
        CGPROGRAM
        #pragma target 3.0
        #pragma vertex VertShader
        #pragma fragment PixShader
        #pragma shader_feature __ BEVEL_ON
        #pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER
        #pragma shader_feature __ GLOW_ON
        #pragma shader_feature __ FORCE_LINEAR

        #pragma multi_compile __ UNITY_UI_CLIP_RECT
        #pragma multi_compile __ UNITY_UI_ALPHACLIP

        #include "UnityCG.cginc"
        #include "UnityUI.cginc"
        #include "TMPro_Properties.cginc"
        #include "TMPro.cginc"

        struct vertex_t
        {
            UNITY_VERTEX_INPUT_INSTANCE_ID
            float4	position        : POSITION;
            float3	normal          : NORMAL;
            float4	color           : COLOR;
            float4	texcoord0       : TEXCOORD0;
            float2	texcoord1       : TEXCOORD1;
        };

        struct pixel_t
        {
            UNITY_VERTEX_INPUT_INSTANCE_ID
            UNITY_VERTEX_OUTPUT_STEREO
            float4	position        : SV_POSITION;
            float4	color           : COLOR;
            float2	atlas           : TEXCOORD0;
            float	weight          : TEXCOORD1;
            float2	mask            : TEXCOORD2;		// Position in object space(xy)
            float3	viewDir         : TEXCOORD3;

            #if (UNDERLAY_ON || UNDERLAY_INNER)
            float2	texcoord2       : TEXCOORD4;
            float4	underlayColor   : COLOR1;
            #endif

            float4 textures         : TEXCOORD5;
        };

        // Used by Unity internally to handle Texture Tiling and Offset.
        float4 _FaceTex_ST;
        float4 _OutlineTex_ST;
        float _UIMaskSoftnessX;
        float _UIMaskSoftnessY;
        int _UIVertexColorAlwaysGammaSpace;

        float4 SRGBToLinear(float4 rgba)
        {
            return float4(lerp(rgba.rgb / 12.92f, pow((rgba.rgb + 0.055f) / 1.055f, 2.4f), step(0.04045f, rgba.rgb)), rgba.a);
        }

        pixel_t VertShader(vertex_t input)
        {
            pixel_t output;

            UNITY_INITIALIZE_OUTPUT(pixel_t, output);
            UNITY_SETUP_INSTANCE_ID(input);
            UNITY_TRANSFER_INSTANCE_ID(input,output);
            UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

            float bold = step(input.texcoord0.w, 0);

            float4 vert = input.position;
            vert.x += _VertexOffsetX;
            vert.y += _VertexOffsetY;

            float4 vPosition = UnityObjectToClipPos(vert);

            float weight = lerp(_WeightNormal, _WeightBold, bold) / 4.0;
            weight = (weight + _FaceDilate) * _ScaleRatioA * 0.5;

            #if (UNDERLAY_ON || UNDERLAY_INNER)
            float4 underlayColor = _UnderlayColor;
            underlayColor.rgb *= underlayColor.a;

            float x = -(_UnderlayOffsetX * _ScaleRatioC) * _GradientScale / _TextureWidth;
            float y = -(_UnderlayOffsetY * _ScaleRatioC) * _GradientScale / _TextureHeight;
            float2 bOffset = float2(x, y);
            #endif

            // Generate UV for the Masking Texture
            float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);

            // Support for texture tiling and offset
            float2 textureUV = input.texcoord1;
            float2 faceUV = TRANSFORM_TEX(textureUV, _FaceTex);
            float2 outlineUV = TRANSFORM_TEX(textureUV, _OutlineTex);

            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                input.color.rgb = UIGammaToLinear(input.color.rgb);
            }
            float4 color = input.color;
            #if (FORCE_LINEAR && !UNITY_COLORSPACE_GAMMA)
            color = SRGBToLinear(input.color);
            #endif

            output.position = vPosition;
            output.color = color;
            output.atlas = input.texcoord0;
            output.weight = weight;
            output.mask = half2(vert.xy * 2 - clampedRect.xy - clampedRect.zw);
            output.viewDir = mul((float3x3)_EnvMatrix, _WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, vert).xyz);
            #if (UNDERLAY_ON || UNDERLAY_INNER)
            output.texcoord2 = input.texcoord0 + bOffset;
            output.underlayColor = underlayColor;
            #endif
            output.textures = float4(faceUV, outlineUV);

            return output;
        }


        fixed4 PixShader(pixel_t input) : SV_Target
        {
            UNITY_SETUP_INSTANCE_ID(input);

            float c = tex2D(_MainTex, input.atlas).a;

            float pixelSize = abs(ddx(input.atlas.y)) + abs(ddy(input.atlas.y));
            pixelSize *= _TextureHeight * 0.75;
            float scale = 1 / pixelSize * _GradientScale * (_Sharpness + 1);

            float weight = input.weight;
            float bias = (.5 - weight) + (.5 / scale);
            float sd = (bias - c) * scale;

            float outline = (_OutlineWidth * _ScaleRatioA) * scale;
            float softness = (_OutlineSoftness * _ScaleRatioA) * scale;

            half4 faceColor = _FaceColor;
            half4 outlineColor = _OutlineColor;

            faceColor.rgb *= input.color.rgb;

            faceColor *= tex2D(_FaceTex, input.textures.xy + float2(_FaceUVSpeedX, _FaceUVSpeedY) * _Time.y);
            outlineColor *= tex2D(_OutlineTex, input.textures.zw + float2(_OutlineUVSpeedX, _OutlineUVSpeedY) * _Time.y);

            faceColor = GetColor(sd, faceColor, outlineColor, outline, softness);

            #if BEVEL_ON
            float3 dxy = float3(0.5 / _TextureWidth, 0.5 / _TextureHeight, 0);
            float3 n = GetSurfaceNormal(input.atlas, weight, dxy);

            float3 bump = UnpackNormal(tex2D(_BumpMap, input.textures.xy + float2(_FaceUVSpeedX, _FaceUVSpeedY) * _Time.y)).xyz;
            bump *= lerp(_BumpFace, _BumpOutline, saturate(sd + outline * 0.5));
            n = normalize(n - bump);

            float3 light = normalize(float3(sin(_LightAngle), cos(_LightAngle), -1.0));

            float3 col = GetSpecular(n, light);
            faceColor.rgb += col * faceColor.a;
            faceColor.rgb *= 1 - (dot(n, light) * _Diffuse);
            faceColor.rgb *= lerp(_Ambient, 1, n.z * n.z);

            fixed4 reflcol = texCUBE(_Cube, reflect(input.viewDir, -n));
            faceColor.rgb += reflcol.rgb * lerp(_ReflectFaceColor.rgb, _ReflectOutlineColor.rgb, saturate(sd + outline * 0.5)) * faceColor.a;
            #endif

            #if (UNDERLAY_ON || UNDERLAY_INNER)
            float bScale = scale;
            bScale /= 1 + ((_UnderlaySoftness * _ScaleRatioC) * bScale);
            float bBias = (0.5 - weight) * bScale - 0.5 - ((_UnderlayDilate * _ScaleRatioC) * 0.5 * bScale);
            #endif

            #if UNDERLAY_ON
            float d = tex2D(_MainTex, input.texcoord2.xy).a * bScale;
            faceColor += input.underlayColor * saturate(d - bBias) * (1 - faceColor.a);
            #endif

            #if UNDERLAY_INNER
            float d = tex2D(_MainTex, input.texcoord2.xy).a * bScale;
            faceColor += input.underlayColor * (1 - saturate(d - bBias)) * saturate(1 - sd) * (1 - faceColor.a);
            #endif

            #if GLOW_ON
            float4 glowColor = GetGlowColor(sd, scale);
            faceColor.rgb += glowColor.rgb * glowColor.a;
            #endif

            // Alternative implementation to UnityGet2DClipping with support for softness.
            #if UNITY_UI_CLIP_RECT
            half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
            float2 maskZW = 0.25 / (0.25 * maskSoftness + 1 / scale);
            half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(input.mask.xy)) * maskZW);
            faceColor *= m.x * m.y;
            #endif

            #if UNITY_UI_ALPHACLIP
            clip(faceColor.a - 0.001);
            #endif

            return faceColor * input.color.a;
        }
        ENDCG
    }
}

Fallback "TextMeshPro/Mobile/Distance Field"
CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile Masking.shader">
// Simplified SDF shader:
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

Shader "TextMeshPro/Mobile/Distance Field - Masking" {

Properties {
	_FaceColor		    ("Face Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineWidth		("Outline Thickness", Range(0,1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_UnderlayColor	    ("Border Color", Color) = (0,0,0,.5)
	_UnderlayOffsetX 	("Border OffsetX", Range(-1,1)) = 0
	_UnderlayOffsetY 	("Border OffsetY", Range(-1,1)) = 0
	_UnderlayDilate		("Border Dilate", Range(-1,1)) = 0
	_UnderlaySoftness 	("Border Softness", Range(0,1)) = 0

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = .5

	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5
	_ScaleX				("Scale X", float) = 1
	_ScaleY				("Scale Y", float) = 1
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_ClipRect			("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
	_MaskSoftnessX		("Mask SoftnessX", float) = 0
	_MaskSoftnessY		("Mask SoftnessY", float) = 0
	_MaskTex			("Mask Texture", 2D) = "white" {}
	_MaskInverse		("Inverse", float) = 0
	_MaskEdgeColor		("Edge Color", Color) = (1,1,1,1)
	_MaskEdgeSoftness	("Edge Softness", Range(0, 1)) = 0.01
	_MaskWipeControl	("Wipe Position", Range(0, 1)) = 0.5

	_StencilComp		("Stencil Comparison", Float) = 8
	_Stencil			("Stencil ID", Float) = 0
	_StencilOp			("Stencil Operation", Float) = 0
	_StencilWriteMask	("Stencil Write Mask", Float) = 255
	_StencilReadMask	("Stencil Read Mask", Float) = 255

	_CullMode			("Cull Mode", Float) = 0
	_ColorMask			("Color Mask", Float) = 15
}

SubShader {
	Tags
	{
		"Queue"="Transparent"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}


	Stencil
	{
		Ref [_Stencil]
		Comp [_StencilComp]
		Pass [_StencilOp]
		ReadMask [_StencilReadMask]
		WriteMask [_StencilWriteMask]
	}

	Cull [_CullMode]
	ZWrite Off
	Lighting Off
	Fog { Mode Off }
	ZTest [unity_GUIZTestMode]
	Blend One OneMinusSrcAlpha
	ColorMask [_ColorMask]

	Pass {
		CGPROGRAM
		#pragma vertex VertShader
		#pragma fragment PixShader
		#pragma shader_feature __ OUTLINE_ON
		#pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP


		#include "UnityCG.cginc"
		#include "UnityUI.cginc"
		#include "TMPro_Properties.cginc"

		struct vertex_t
		{
			float4	vertex			: POSITION;
			float3	normal			: NORMAL;
			fixed4	color			: COLOR;
			float4	texcoord0		: TEXCOORD0;
			float2	texcoord1		: TEXCOORD1;
		};

		struct pixel_t
		{
			float4	vertex			: SV_POSITION;
			fixed4	faceColor		: COLOR;
			fixed4	outlineColor	: COLOR1;
			float4	texcoord0		: TEXCOORD0;			// Texture UV, Mask UV
			half4	param			: TEXCOORD1;			// Scale(x), BiasIn(y), BiasOut(z), Bias(w)
			half4	mask			: TEXCOORD2;			// Position in clip space(xy), Softness(zw)

		    #if (UNDERLAY_ON | UNDERLAY_INNER)
			float4	texcoord1		: TEXCOORD3;			// Texture UV, alpha, reserved
			half2	underlayParam	: TEXCOORD4;			// Scale(x), Bias(y)
		    #endif
		};

		float _MaskWipeControl;
		float _MaskEdgeSoftness;
		fixed4 _MaskEdgeColor;
		bool _MaskInverse;
		float _UIMaskSoftnessX;
        float _UIMaskSoftnessY;
        int _UIVertexColorAlwaysGammaSpace;

		pixel_t VertShader(vertex_t input)
		{
			float bold = step(input.texcoord0.w, 0);

			float4 vert = input.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;
			float4 vPosition = UnityObjectToClipPos(vert);

			float2 pixelSize = vPosition.w;
			pixelSize /= float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));

			float scale = rsqrt(dot(pixelSize, pixelSize));
			scale *= abs(input.texcoord0.w) * _GradientScale * (_Sharpness + 1);
			if(UNITY_MATRIX_P[3][3] == 0) scale = lerp(abs(scale) * (1 - _PerspectiveFilter), scale, abs(dot(UnityObjectToWorldNormal(input.normal.xyz), normalize(WorldSpaceViewDir(vert)))));

			float weight = lerp(_WeightNormal, _WeightBold, bold) / 4.0;
			weight = (weight + _FaceDilate) * _ScaleRatioA * 0.5;

			float layerScale = scale;

			scale /= 1 + (_OutlineSoftness * _ScaleRatioA * scale);
			float bias = (0.5 - weight) * scale - 0.5;
			float outline = _OutlineWidth * _ScaleRatioA * 0.5 * scale;

            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                input.color.rgb = UIGammaToLinear(input.color.rgb);
            }
			float opacity = input.color.a;
					#if (UNDERLAY_ON | UNDERLAY_INNER)
					opacity = 1.0;
					#endif

			fixed4 faceColor = fixed4(input.color.rgb, opacity) * _FaceColor;
			faceColor.rgb *= faceColor.a;

			fixed4 outlineColor = _OutlineColor;
			outlineColor.a *= opacity;
			outlineColor.rgb *= outlineColor.a;
			outlineColor = lerp(faceColor, outlineColor, sqrt(min(1.0, (outline * 2))));

		    #if (UNDERLAY_ON | UNDERLAY_INNER)

			layerScale /= 1 + ((_UnderlaySoftness * _ScaleRatioC) * layerScale);
			float layerBias = (.5 - weight) * layerScale - .5 - ((_UnderlayDilate * _ScaleRatioC) * .5 * layerScale);

			float x = -(_UnderlayOffsetX * _ScaleRatioC) * _GradientScale / _TextureWidth;
			float y = -(_UnderlayOffsetY * _ScaleRatioC) * _GradientScale / _TextureHeight;
			float2 layerOffset = float2(x, y);
		    #endif

			// Generate UV for the Masking Texture
			float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			float2 maskUV = (vert.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);
			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));

			// Structure for pixel shader
			pixel_t output = {
				vPosition,
				faceColor,
				outlineColor,
				float4(input.texcoord0.x, input.texcoord0.y, maskUV.x, maskUV.y),
				half4(scale, bias - outline, bias + outline, bias),
				half4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy)),
			    #if (UNDERLAY_ON | UNDERLAY_INNER)
				float4(input.texcoord0 + layerOffset, input.color.a, 0),
				half2(layerScale, layerBias),
			    #endif
			};

			return output;
		}


		// PIXEL SHADER
		fixed4 PixShader(pixel_t input) : SV_Target
		{
			half d = tex2D(_MainTex, input.texcoord0.xy).a * input.param.x;
			half4 c = input.faceColor * saturate(d - input.param.w);

		    #ifdef OUTLINE_ON
			c = lerp(input.outlineColor, input.faceColor, saturate(d - input.param.z));
			c *= saturate(d - input.param.y);
		    #endif

		    #if UNDERLAY_ON
			d = tex2D(_MainTex, input.texcoord1.xy).a * input.underlayParam.x;
			c += float4(_UnderlayColor.rgb * _UnderlayColor.a, _UnderlayColor.a) * saturate(d - input.underlayParam.y) * (1 - c.a);
		    #endif

		    #if UNDERLAY_INNER
			half sd = saturate(d - input.param.z);
			d = tex2D(_MainTex, input.texcoord1.xy).a * input.underlayParam.x;
			c += float4(_UnderlayColor.rgb * _UnderlayColor.a, _UnderlayColor.a) * (1 - saturate(d - input.underlayParam.y)) * sd * (1 - c.a);
		    #endif

		    // Alternative implementation to UnityGet2DClipping with support for softness.
		    //#if UNITY_UI_CLIP_RECT
			half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(input.mask.xy)) * input.mask.zw);
			c *= m.x * m.y;
		    //#endif

		    float a = abs(_MaskInverse - tex2D(_MaskTex, input.texcoord0.zw).a);
		    float t = a + (1 - _MaskWipeControl) * _MaskEdgeSoftness - _MaskWipeControl;
		    a = saturate(t / _MaskEdgeSoftness);
		    c.rgb = lerp(_MaskEdgeColor.rgb*c.a, c.rgb, a);
		    c *= a;

		    #if (UNDERLAY_ON | UNDERLAY_INNER)
			c *= input.texcoord1.z;
		    #endif

		    #if UNITY_UI_ALPHACLIP
			clip(c.a - 0.001);
		    #endif

			return c;
		}
		ENDCG
	}
}

CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile Overlay.shader">
// Simplified SDF shader:
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

Shader "TextMeshPro/Mobile/Distance Field Overlay" {

Properties {
	_FaceColor		    ("Face Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineWidth		("Outline Thickness", Range(0,1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_UnderlayColor	    ("Border Color", Color) = (0,0,0,.5)
	_UnderlayOffsetX 	("Border OffsetX", Range(-1,1)) = 0
	_UnderlayOffsetY 	("Border OffsetY", Range(-1,1)) = 0
	_UnderlayDilate		("Border Dilate", Range(-1,1)) = 0
	_UnderlaySoftness 	("Border Softness", Range(0,1)) = 0

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = .5

	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5
	_ScaleX				("Scale X", float) = 1
	_ScaleY				("Scale Y", float) = 1
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_ClipRect			("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
	_MaskSoftnessX		("Mask SoftnessX", float) = 0
	_MaskSoftnessY		("Mask SoftnessY", float) = 0

	_StencilComp		("Stencil Comparison", Float) = 8
	_Stencil			("Stencil ID", Float) = 0
	_StencilOp			("Stencil Operation", Float) = 0
	_StencilWriteMask	("Stencil Write Mask", Float) = 255
	_StencilReadMask	("Stencil Read Mask", Float) = 255

	_CullMode			("Cull Mode", Float) = 0
	_ColorMask			("Color Mask", Float) = 15
}

SubShader {
	Tags
  {
		"Queue"="Overlay"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}


	Stencil
	{
		Ref [_Stencil]
		Comp [_StencilComp]
		Pass [_StencilOp]
		ReadMask [_StencilReadMask]
		WriteMask [_StencilWriteMask]
	}

	Cull [_CullMode]
	ZWrite Off
	Lighting Off
	Fog { Mode Off }
	ZTest Always
	Blend One OneMinusSrcAlpha
	ColorMask [_ColorMask]

	Pass {
		CGPROGRAM
		#pragma vertex VertShader
		#pragma fragment PixShader
		#pragma shader_feature __ OUTLINE_ON
		#pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP

		#include "UnityCG.cginc"
		#include "UnityUI.cginc"
		#include "TMPro_Properties.cginc"

		struct vertex_t
		{
			UNITY_VERTEX_INPUT_INSTANCE_ID
			float4	vertex			: POSITION;
			float3	normal			: NORMAL;
			fixed4	color			: COLOR;
			float4	texcoord0		: TEXCOORD0;
			float2	texcoord1		: TEXCOORD1;
		};

		struct pixel_t
		{
			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
			float4	vertex			: SV_POSITION;
			fixed4	faceColor		: COLOR;
			fixed4	outlineColor	: COLOR1;
			float4	texcoord0		: TEXCOORD0;			// Texture UV, Mask UV
			half4	param			: TEXCOORD1;			// Scale(x), BiasIn(y), BiasOut(z), Bias(w)
			half4	mask			: TEXCOORD2;			// Position in clip space(xy), Softness(zw)

		    #if (UNDERLAY_ON | UNDERLAY_INNER)
			float4	texcoord1		: TEXCOORD3;			// Texture UV, alpha, reserved
			half2	underlayParam	: TEXCOORD4;			// Scale(x), Bias(y)
		    #endif
		};

		float _UIMaskSoftnessX;
        float _UIMaskSoftnessY;
        int _UIVertexColorAlwaysGammaSpace;


		pixel_t VertShader(vertex_t input)
		{
			pixel_t output;

			UNITY_INITIALIZE_OUTPUT(pixel_t, output);
			UNITY_SETUP_INSTANCE_ID(input);
			UNITY_TRANSFER_INSTANCE_ID(input, output);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

			float bold = step(input.texcoord0.w, 0);

			float4 vert = input.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;
			float4 vPosition = UnityObjectToClipPos(vert);

			float2 pixelSize = vPosition.w;
			pixelSize /= float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));

			float scale = rsqrt(dot(pixelSize, pixelSize));
			scale *= abs(input.texcoord0.w) * _GradientScale * (_Sharpness + 1);
			if(UNITY_MATRIX_P[3][3] == 0) scale = lerp(abs(scale) * (1 - _PerspectiveFilter), scale, abs(dot(UnityObjectToWorldNormal(input.normal.xyz), normalize(WorldSpaceViewDir(vert)))));

			float weight = lerp(_WeightNormal, _WeightBold, bold) / 4.0;
			weight = (weight + _FaceDilate) * _ScaleRatioA * 0.5;

			float layerScale = scale;

			scale /= 1 + (_OutlineSoftness * _ScaleRatioA * scale);
			float bias = (0.5 - weight) * scale - 0.5;
			float outline = _OutlineWidth * _ScaleRatioA * 0.5 * scale;

            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                input.color.rgb = UIGammaToLinear(input.color.rgb);
            }
			float opacity = input.color.a;
		    #if (UNDERLAY_ON | UNDERLAY_INNER)
				opacity = 1.0;
		    #endif

			fixed4 faceColor = fixed4(input.color.rgb, opacity) * _FaceColor;
			faceColor.rgb *= faceColor.a;

			fixed4 outlineColor = _OutlineColor;
			outlineColor.a *= opacity;
			outlineColor.rgb *= outlineColor.a;
			outlineColor = lerp(faceColor, outlineColor, sqrt(min(1.0, (outline * 2))));

		    #if (UNDERLAY_ON | UNDERLAY_INNER)
			layerScale /= 1 + ((_UnderlaySoftness * _ScaleRatioC) * layerScale);
			float layerBias = (.5 - weight) * layerScale - .5 - ((_UnderlayDilate * _ScaleRatioC) * .5 * layerScale);

			float x = -(_UnderlayOffsetX * _ScaleRatioC) * _GradientScale / _TextureWidth;
			float y = -(_UnderlayOffsetY * _ScaleRatioC) * _GradientScale / _TextureHeight;
			float2 layerOffset = float2(x, y);
		    #endif

			// Generate UV for the Masking Texture
			float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			float2 maskUV = (vert.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);

			// Populate structure for pixel shader
			output.vertex = vPosition;
			output.faceColor = faceColor;
			output.outlineColor = outlineColor;
			output.texcoord0 = float4(input.texcoord0.x, input.texcoord0.y, maskUV.x, maskUV.y);
			output.param = half4(scale, bias - outline, bias + outline, bias);
			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			output.mask = half4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));
			#if (UNDERLAY_ON || UNDERLAY_INNER)
			output.texcoord1 = float4(input.texcoord0 + layerOffset, input.color.a, 0);
			output.underlayParam = half2(layerScale, layerBias);
			#endif

			return output;
		}


		// PIXEL SHADER
		fixed4 PixShader(pixel_t input) : SV_Target
		{
			UNITY_SETUP_INSTANCE_ID(input);

			half d = tex2D(_MainTex, input.texcoord0.xy).a * input.param.x;
			half4 c = input.faceColor * saturate(d - input.param.w);

		    #ifdef OUTLINE_ON
			c = lerp(input.outlineColor, input.faceColor, saturate(d - input.param.z));
			c *= saturate(d - input.param.y);
		    #endif

		    #if UNDERLAY_ON
			d = tex2D(_MainTex, input.texcoord1.xy).a * input.underlayParam.x;
			c += float4(_UnderlayColor.rgb * _UnderlayColor.a, _UnderlayColor.a) * saturate(d - input.underlayParam.y) * (1 - c.a);
		    #endif

		    #if UNDERLAY_INNER
			half sd = saturate(d - input.param.z);
			d = tex2D(_MainTex, input.texcoord1.xy).a * input.underlayParam.x;
			c += float4(_UnderlayColor.rgb * _UnderlayColor.a, _UnderlayColor.a) * (1 - saturate(d - input.underlayParam.y)) * sd * (1 - c.a);
		    #endif

		    // Alternative implementation to UnityGet2DClipping with support for softness.
		    #if UNITY_UI_CLIP_RECT
			half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(input.mask.xy)) * input.mask.zw);
			c *= m.x * m.y;
		    #endif

		    #if (UNDERLAY_ON | UNDERLAY_INNER)
			c *= input.texcoord1.z;
		    #endif

            #if UNITY_UI_ALPHACLIP
			clip(c.a - 0.001);
		    #endif

			return c;
		}
		ENDCG
	}
}

CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile SSD.shader">
// Simplified SDF shader:
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

Shader "TextMeshPro/Mobile/Distance Field SSD" {

Properties {
	_FaceColor		    ("Face Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineWidth		("Outline Thickness", Range(0,1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_UnderlayColor		("Border Color", Color) = (0,0,0,.5)
	_UnderlayOffsetX 	("Border OffsetX", Range(-1,1)) = 0
	_UnderlayOffsetY 	("Border OffsetY", Range(-1,1)) = 0
	_UnderlayDilate		("Border Dilate", Range(-1,1)) = 0
	_UnderlaySoftness 	("Border Softness", Range(0,1)) = 0

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = .5

	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5
	_ScaleX				("Scale X", float) = 1
	_ScaleY				("Scale Y", float) = 1
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_ClipRect			("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
	_MaskSoftnessX		("Mask SoftnessX", float) = 0
	_MaskSoftnessY		("Mask SoftnessY", float) = 0
	_MaskTex			("Mask Texture", 2D) = "white" {}
	_MaskInverse		("Inverse", float) = 0
	_MaskEdgeColor		("Edge Color", Color) = (1,1,1,1)
	_MaskEdgeSoftness	("Edge Softness", Range(0, 1)) = 0.01
	_MaskWipeControl	("Wipe Position", Range(0, 1)) = 0.5

	_StencilComp		("Stencil Comparison", Float) = 8
	_Stencil			("Stencil ID", Float) = 0
	_StencilOp			("Stencil Operation", Float) = 0
	_StencilWriteMask	("Stencil Write Mask", Float) = 255
	_StencilReadMask	("Stencil Read Mask", Float) = 255

    _CullMode           ("Cull Mode", Float) = 0
	_ColorMask			("Color Mask", Float) = 15
}

SubShader {
	Tags {
		"Queue"="Transparent"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}

	Stencil
	{
		Ref [_Stencil]
		Comp [_StencilComp]
		Pass [_StencilOp]
		ReadMask [_StencilReadMask]
		WriteMask [_StencilWriteMask]
	}

	Cull [_CullMode]
	ZWrite Off
	Lighting Off
	Fog { Mode Off }
	ZTest [unity_GUIZTestMode]
	Blend One OneMinusSrcAlpha
	ColorMask [_ColorMask]

	Pass {
		CGPROGRAM
		#pragma vertex VertShader
		#pragma fragment PixShader
		#pragma shader_feature __ OUTLINE_ON
		#pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP

		#include "UnityCG.cginc"
		#include "UnityUI.cginc"
		#include "TMPro_Properties.cginc"

		#include "TMPro_Mobile.cginc"

		ENDCG
	}
}

CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile-2-Pass.shader">
// Simplified SDF shader:
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

Shader "TextMeshPro/Mobile/Distance Field - 2 Pass" {

Properties {
	_FaceColor          ("Face Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineWidth		("Outline Thickness", Range(0,1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_UnderlayColor	    ("Border Color", Color) = (0,0,0,.5)
	_UnderlayOffsetX 	("Border OffsetX", Range(-1,1)) = 0
	_UnderlayOffsetY 	("Border OffsetY", Range(-1,1)) = 0
	_UnderlayDilate		("Border Dilate", Range(-1,1)) = 0
	_UnderlaySoftness 	("Border Softness", Range(0,1)) = 0

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = .5

	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5
	_ScaleX				("Scale X", float) = 1
	_ScaleY				("Scale Y", float) = 1
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_ClipRect			("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
	_MaskSoftnessX		("Mask SoftnessX", float) = 0
	_MaskSoftnessY		("Mask SoftnessY", float) = 0

	_StencilComp		("Stencil Comparison", Float) = 8
	_Stencil			("Stencil ID", Float) = 0
	_StencilOp			("Stencil Operation", Float) = 0
	_StencilWriteMask	("Stencil Write Mask", Float) = 255
	_StencilReadMask	("Stencil Read Mask", Float) = 255

	_CullMode			("Cull Mode", Float) = 0
	_ColorMask			("Color Mask", Float) = 15
}

SubShader {

	// Draw Outline and Underlay
	Name "Outline"

	Tags
	{
		"Queue"="Transparent"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}

	Stencil
	{
		Ref [_Stencil]
		Comp [_StencilComp]
		Pass [_StencilOp]
		ReadMask [_StencilReadMask]
		WriteMask [_StencilWriteMask]
	}

	Cull [_CullMode]
	ZWrite Off
	Lighting Off
	Fog { Mode Off }
	ZTest [unity_GUIZTestMode]
	Blend One OneMinusSrcAlpha
	ColorMask [_ColorMask]

	Pass {
		CGPROGRAM
		#pragma vertex VertShader
		#pragma fragment PixShader
		#pragma shader_feature __ OUTLINE_ON
		#pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP

		#include "UnityCG.cginc"
		#include "UnityUI.cginc"
		#include "TMPro_Properties.cginc"

		struct vertex_t {
			UNITY_VERTEX_INPUT_INSTANCE_ID
			float4	vertex			: POSITION;
			float3	normal			: NORMAL;
			fixed4	color			: COLOR;
			float4	texcoord0		: TEXCOORD0;
			float2	texcoord1		: TEXCOORD1;
		};

		struct pixel_t {
			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
			float4	vertex			: SV_POSITION;
			fixed4	faceColor		: COLOR;
			fixed4	outlineColor	: COLOR1;
			float4	texcoord0		: TEXCOORD0;			// Texture UV, Mask UV
			half4	param			: TEXCOORD1;			// Scale(x), BiasIn(y), BiasOut(z), Bias(w)
			half4	mask			: TEXCOORD2;			// Position in clip space(xy), Softness(zw)
			#if (UNDERLAY_ON | UNDERLAY_INNER)
			float4	texcoord1		: TEXCOORD3;			// Texture UV, alpha, reserved
			half2	underlayParam	: TEXCOORD4;			// Scale(x), Bias(y)
			#endif
		};

		float _UIMaskSoftnessX;
        float _UIMaskSoftnessY;

		pixel_t VertShader(vertex_t input)
		{
			pixel_t output;

			UNITY_INITIALIZE_OUTPUT(pixel_t, output);
			UNITY_SETUP_INSTANCE_ID(input);
			UNITY_TRANSFER_INSTANCE_ID(input, output);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

			const float bold = step(input.texcoord0.w, 0);

			float4 vert = input.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;
			float4 vPosition = UnityObjectToClipPos(vert);

			float2 pixelSize = vPosition.w;
			pixelSize /= float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));

			float scale = rsqrt(dot(pixelSize, pixelSize));
			scale *= abs(input.texcoord0.w) * _GradientScale * (_Sharpness + 1);
			if(UNITY_MATRIX_P[3][3] == 0) scale = lerp(abs(scale) * (1 - _PerspectiveFilter), scale, abs(dot(UnityObjectToWorldNormal(input.normal.xyz), normalize(WorldSpaceViewDir(vert)))));

			float weight = lerp(_WeightNormal, _WeightBold, bold) / 4.0;
			weight = (weight + _FaceDilate) * _ScaleRatioA * 0.5;

			float layerScale = scale;

			scale /= 1 + (_OutlineSoftness * _ScaleRatioA * scale);
			float bias = (0.5 - weight) * scale - 0.5;
			const float outline = _OutlineWidth * _ScaleRatioA * 0.5 * scale;

			float opacity = input.color.a;
			#if (UNDERLAY_ON | UNDERLAY_INNER)
			opacity = 1.0;
			#endif

			fixed4 faceColor = fixed4(input.color.rgb, opacity) * _FaceColor;
			faceColor.rgb *= faceColor.a;

			fixed4 outlineColor = _OutlineColor;
			outlineColor.a *= opacity;
			outlineColor.rgb *= outlineColor.a;
			//outlineColor = lerp(faceColor, outlineColor, sqrt(min(1.0, outline * 2)));

			#if (UNDERLAY_ON | UNDERLAY_INNER)
			layerScale /= 1 + ((_UnderlaySoftness * _ScaleRatioC) * layerScale);
			float layerBias = (.5 - weight) * layerScale - .5 - ((_UnderlayDilate * _ScaleRatioC) * .5 * layerScale);

			float x = -(_UnderlayOffsetX * _ScaleRatioC) * _GradientScale / _TextureWidth;
			float y = -(_UnderlayOffsetY * _ScaleRatioC) * _GradientScale / _TextureHeight;
			float2 layerOffset = float2(x, y);
			#endif

			// Generate UV for the Masking Texture
			float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			float2 maskUV = (vert.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);

			// Populate structure for pixel shader
			output.vertex = vPosition;
			output.faceColor = faceColor;
			output.outlineColor = outlineColor;
			output.texcoord0 = float4(input.texcoord0.x, input.texcoord0.y, maskUV.x, maskUV.y);
			output.param = half4(scale, bias - outline, bias + outline, bias);

			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			output.mask = half4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));
			#if (UNDERLAY_ON || UNDERLAY_INNER)
			output.texcoord1 = float4(input.texcoord0 + layerOffset, input.color.a, 0);
			output.underlayParam = half2(layerScale, layerBias);
			#endif

			return output;
		}


		// PIXEL SHADER
		fixed4 PixShader(pixel_t input) : SV_Target
		{
			UNITY_SETUP_INSTANCE_ID(input);

			half d = tex2D(_MainTex, input.texcoord0.xy).a * input.param.x;
			half4 c = half4(0, 0, 0, 0);

			#if OUTLINE_ON
			c = input.outlineColor * saturate(d - input.param.y);
			#endif

			#if UNDERLAY_ON
			d = tex2D(_MainTex, input.texcoord1.xy).a * input.underlayParam.x;
			c += float4(_UnderlayColor.rgb * _UnderlayColor.a, _UnderlayColor.a) * saturate(d - input.underlayParam.y) * (1 - c.a);
			#endif

			#if UNDERLAY_INNER
			half sd = saturate(d - input.param.z);
			d = tex2D(_MainTex, input.texcoord1.xy).a * input.underlayParam.x;
			c += float4(_UnderlayColor.rgb * _UnderlayColor.a, _UnderlayColor.a) * (1 - saturate(d - input.underlayParam.y)) * sd * (1 - c.a);
			#endif

			// Alternative implementation to UnityGet2DClipping with support for softness.
			#if UNITY_UI_CLIP_RECT
			half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(input.mask.xy)) * input.mask.zw);
			c *= m.x * m.y;
			#endif

			#if (UNDERLAY_ON | UNDERLAY_INNER)
			c *= input.texcoord1.z;
		    #endif

		    #if UNITY_UI_ALPHACLIP
			clip(c.a - 0.001);
		    #endif

			return c;
		}
		ENDCG
	}


	// Draw face
	Name "Face"

	Tags
	{
		"Queue"="Transparent"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}

	Stencil
	{
		Ref [_Stencil]
		Comp [_StencilComp]
		Pass [_StencilOp]
		ReadMask [_StencilReadMask]
		WriteMask [_StencilWriteMask]
	}

	Cull [_CullMode]
	ZWrite Off
	Lighting Off
	Fog { Mode Off }
	ZTest [unity_GUIZTestMode]
	Blend One OneMinusSrcAlpha
	ColorMask [_ColorMask]

	Pass {
		CGPROGRAM
		#pragma vertex VertShader
		#pragma fragment PixShader

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP

		#include "UnityCG.cginc"
		#include "UnityUI.cginc"
		#include "TMPro_Properties.cginc"

		struct vertex_t {
			UNITY_VERTEX_INPUT_INSTANCE_ID
            float4	vertex			: POSITION;
			float3	normal			: NORMAL;
			fixed4	color			: COLOR;
			float4	texcoord0		: TEXCOORD0;
			float2	texcoord1		: TEXCOORD1;
		};

		struct pixel_t {
			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
            float4	vertex			: SV_POSITION;
			fixed4	faceColor		: COLOR;
			float4	texcoord0		: TEXCOORD0;			// Texture UV, Mask UV
			half2	param			: TEXCOORD1;			// Scale(x), BiasIn(y), BiasOut(z), Bias(w)
			half4	mask			: TEXCOORD2;			// Position in clip space(xy), Softness(zw)
		};

		float _UIMaskSoftnessX;
        float _UIMaskSoftnessY;
        int _UIVertexColorAlwaysGammaSpace;


		pixel_t VertShader(vertex_t input)
		{
			pixel_t output;

			UNITY_INITIALIZE_OUTPUT(pixel_t, output);
			UNITY_SETUP_INSTANCE_ID(input);
			UNITY_TRANSFER_INSTANCE_ID(input, output);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

			const float bold = step(input.texcoord0.w, 0);

			float4 vert = input.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;
			float4 vPosition = UnityObjectToClipPos(vert);

			float2 pixelSize = vPosition.w;
			pixelSize /= float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));

			float scale = rsqrt(dot(pixelSize, pixelSize));
			scale *= abs(input.texcoord0.w) * _GradientScale * (_Sharpness + 1);
			if(UNITY_MATRIX_P[3][3] == 0) scale = lerp(abs(scale) * (1 - _PerspectiveFilter), scale, abs(dot(UnityObjectToWorldNormal(input.normal.xyz), normalize(WorldSpaceViewDir(vert)))));

			float weight = lerp(_WeightNormal, _WeightBold, bold) / 4.0;
			weight = (weight + _FaceDilate) * _ScaleRatioA * 0.5;

			scale /= 1 + (_OutlineSoftness * _ScaleRatioA * scale);
			float bias = (0.5 - weight) * scale - 0.5;

            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                input.color.rgb = UIGammaToLinear(input.color.rgb);
            }
			float opacity = input.color.a;

			fixed4 faceColor = fixed4(input.color.rgb, opacity) * _FaceColor;
			faceColor.rgb *= faceColor.a;

			// Generate UV for the Masking Texture
			float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			float2 maskUV = (vert.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);

			// Populate structure for pixel shader
			output.vertex = vPosition;
			output.faceColor = faceColor;
			output.texcoord0 = float4(input.texcoord0.x, input.texcoord0.y, maskUV.x, maskUV.y);
			output.param = half2(scale, bias);

			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			output.mask = half4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));

			return output;
		}


		// PIXEL SHADER
		fixed4 PixShader(pixel_t input) : SV_Target
		{
			UNITY_SETUP_INSTANCE_ID(input);

			half d = tex2D(_MainTex, input.texcoord0.xy).a * input.param.x;
			half4 c = input.faceColor * saturate(d - input.param.y);

		    // Alternative implementation to UnityGet2DClipping with support for softness.
			#if UNITY_UI_CLIP_RECT
			half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(input.mask.xy)) * input.mask.zw);
			c *= m.x * m.y;
			#endif

		    #if UNITY_UI_ALPHACLIP
			clip(c.a - 0.001);
		    #endif

			return c;
		}
		ENDCG
	}

}

CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF-Mobile.shader">
// Simplified SDF shader:
// - No Shading Option (bevel / bump / env map)
// - No Glow Option
// - Softness is applied on both side of the outline

Shader "TextMeshPro/Mobile/Distance Field" {

Properties {
	_FaceColor          ("Face Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineWidth		("Outline Thickness", Range(0,1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_UnderlayColor	    ("Border Color", Color) = (0,0,0,.5)
	_UnderlayOffsetX 	("Border OffsetX", Range(-1,1)) = 0
	_UnderlayOffsetY 	("Border OffsetY", Range(-1,1)) = 0
	_UnderlayDilate		("Border Dilate", Range(-1,1)) = 0
	_UnderlaySoftness 	("Border Softness", Range(0,1)) = 0

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = .5

	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5
	_ScaleX				("Scale X", float) = 1
	_ScaleY				("Scale Y", float) = 1
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_ClipRect			("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
	_MaskSoftnessX		("Mask SoftnessX", float) = 0
	_MaskSoftnessY		("Mask SoftnessY", float) = 0

	_StencilComp		("Stencil Comparison", Float) = 8
	_Stencil			("Stencil ID", Float) = 0
	_StencilOp			("Stencil Operation", Float) = 0
	_StencilWriteMask	("Stencil Write Mask", Float) = 255
	_StencilReadMask	("Stencil Read Mask", Float) = 255

	_CullMode			("Cull Mode", Float) = 0
	_ColorMask			("Color Mask", Float) = 15
}

SubShader {
	Tags
	{
		"Queue"="Transparent"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}


	Stencil
	{
		Ref [_Stencil]
		Comp [_StencilComp]
		Pass [_StencilOp]
		ReadMask [_StencilReadMask]
		WriteMask [_StencilWriteMask]
	}

	Cull [_CullMode]
	ZWrite Off
	Lighting Off
	Fog { Mode Off }
	ZTest [unity_GUIZTestMode]
	Blend One OneMinusSrcAlpha
	ColorMask [_ColorMask]

	Pass {
		CGPROGRAM
		#pragma enable_d3d11_debug_symbols
		#pragma vertex VertShader
		#pragma fragment PixShader
		#pragma shader_feature __ OUTLINE_ON
		#pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP

		#include "UnityCG.cginc"
		#include "UnityUI.cginc"
		#include "TMPro_Properties.cginc"

		struct vertex_t {
			UNITY_VERTEX_INPUT_INSTANCE_ID
			float4	vertex			: POSITION;
			float3	normal			: NORMAL;
			fixed4	color			: COLOR;
			float4	texcoord0		: TEXCOORD0;
			float2	texcoord1		: TEXCOORD1;
		};

		struct pixel_t {
			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
			float4	vertex			: SV_POSITION;
			fixed4	faceColor		: COLOR;
			fixed4	outlineColor	: COLOR1;
			float4	texcoord0		: TEXCOORD0;			// Texture UV, Mask UV
			half4	param			: TEXCOORD1;			// Scale(x), BiasIn(y), BiasOut(z), Bias(w)
			half4	mask			: TEXCOORD2;			// Position in clip space(xy), Softness(zw)
			#if (UNDERLAY_ON | UNDERLAY_INNER)
			float4	texcoord1		: TEXCOORD3;			// Texture UV, alpha, reserved
			half2	underlayParam	: TEXCOORD4;			// Scale(x), Bias(y)
			#endif
		};

		float _UIMaskSoftnessX;
        float _UIMaskSoftnessY;
        int _UIVertexColorAlwaysGammaSpace;

		pixel_t VertShader(vertex_t input)
		{
			pixel_t output;

			UNITY_INITIALIZE_OUTPUT(pixel_t, output);
			UNITY_SETUP_INSTANCE_ID(input);
			UNITY_TRANSFER_INSTANCE_ID(input, output);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

			float bold = step(input.texcoord0.w, 0);

			float4 vert = input.vertex;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;
			float4 vPosition = UnityObjectToClipPos(vert);

			float2 pixelSize = vPosition.w;
			pixelSize /= float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));

			float scale = rsqrt(dot(pixelSize, pixelSize));
			scale *= abs(input.texcoord0.w) * _GradientScale * (_Sharpness + 1);
			if(UNITY_MATRIX_P[3][3] == 0) scale = lerp(abs(scale) * (1 - _PerspectiveFilter), scale, abs(dot(UnityObjectToWorldNormal(input.normal.xyz), normalize(WorldSpaceViewDir(vert)))));

			float weight = lerp(_WeightNormal, _WeightBold, bold) / 4.0;
			weight = (weight + _FaceDilate) * _ScaleRatioA * 0.5;

			float layerScale = scale;

			scale /= 1 + (_OutlineSoftness * _ScaleRatioA * scale);
			float bias = (0.5 - weight) * scale - 0.5;
			float outline = _OutlineWidth * _ScaleRatioA * 0.5 * scale;

            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                input.color.rgb = UIGammaToLinear(input.color.rgb);
            }
            float opacity = input.color.a;
			#if (UNDERLAY_ON | UNDERLAY_INNER)
			opacity = 1.0;
			#endif

			fixed4 faceColor = fixed4(input.color.rgb, opacity) * _FaceColor;
			faceColor.rgb *= faceColor.a;

			fixed4 outlineColor = _OutlineColor;
			outlineColor.a *= opacity;
			outlineColor.rgb *= outlineColor.a;
			outlineColor = lerp(faceColor, outlineColor, sqrt(min(1.0, (outline * 2))));

			#if (UNDERLAY_ON | UNDERLAY_INNER)
			layerScale /= 1 + ((_UnderlaySoftness * _ScaleRatioC) * layerScale);
			float layerBias = (.5 - weight) * layerScale - .5 - ((_UnderlayDilate * _ScaleRatioC) * .5 * layerScale);

			float x = -(_UnderlayOffsetX * _ScaleRatioC) * _GradientScale / _TextureWidth;
			float y = -(_UnderlayOffsetY * _ScaleRatioC) * _GradientScale / _TextureHeight;
			float2 layerOffset = float2(x, y);
			#endif

			// Generate UV for the Masking Texture
			float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			float2 maskUV = (vert.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);

			// Populate structure for pixel shader
			output.vertex = vPosition;
			output.faceColor = faceColor;
			output.outlineColor = outlineColor;
			output.texcoord0 = float4(input.texcoord0.x, input.texcoord0.y, maskUV.x, maskUV.y);
			output.param = half4(scale, bias - outline, bias + outline, bias);

			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			output.mask = half4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));
			#if (UNDERLAY_ON || UNDERLAY_INNER)
			output.texcoord1 = float4(input.texcoord0 + layerOffset, input.color.a, 0);
			output.underlayParam = half2(layerScale, layerBias);
			#endif

			return output;
		}


		// PIXEL SHADER
		fixed4 PixShader(pixel_t input) : SV_Target
		{
			UNITY_SETUP_INSTANCE_ID(input);

			half d = tex2D(_MainTex, input.texcoord0.xy).a * input.param.x;
			half4 c = input.faceColor * saturate(d - input.param.w);

			#ifdef OUTLINE_ON
			c = lerp(input.outlineColor, input.faceColor, saturate(d - input.param.z));
			c *= saturate(d - input.param.y);
			#endif

			#if UNDERLAY_ON
			d = tex2D(_MainTex, input.texcoord1.xy).a * input.underlayParam.x;
			c += float4(_UnderlayColor.rgb * _UnderlayColor.a, _UnderlayColor.a) * saturate(d - input.underlayParam.y) * (1 - c.a);
			#endif

			#if UNDERLAY_INNER
			half sd = saturate(d - input.param.z);
			d = tex2D(_MainTex, input.texcoord1.xy).a * input.underlayParam.x;
			c += float4(_UnderlayColor.rgb * _UnderlayColor.a, _UnderlayColor.a) * (1 - saturate(d - input.underlayParam.y)) * sd * (1 - c.a);
			#endif

			// Alternative implementation to UnityGet2DClipping with support for softness.
			#if UNITY_UI_CLIP_RECT
			half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(input.mask.xy)) * input.mask.zw);
			c *= m.x * m.y;
			#endif

			#if (UNDERLAY_ON | UNDERLAY_INNER)
			c *= input.texcoord1.z;
			#endif

			#if UNITY_UI_ALPHACLIP
			clip(c.a - 0.001);
			#endif

			return c;
		}
		ENDCG
	}
}

CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF-Surface-Mobile.shader">
// Simplified version of the SDF Surface shader :
// - No support for Bevel, Bump or envmap
// - Diffuse only lighting
// - Fully supports only 1 directional light. Other lights can affect it, but it will be per-vertex/SH.

Shader "TextMeshPro/Mobile/Distance Field (Surface)" {

Properties {
	_FaceTex			("Fill Texture", 2D) = "white" {}
	_FaceColor		    ("Fill Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineTex			("Outline Texture", 2D) = "white" {}
	_OutlineWidth		("Outline Thickness", Range(0, 1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_GlowColor		    ("Color", Color) = (0, 1, 0, 0.5)
	_GlowOffset			("Offset", Range(-1,1)) = 0
	_GlowInner			("Inner", Range(0,1)) = 0.05
	_GlowOuter			("Outer", Range(0,1)) = 0.05
	_GlowPower			("Falloff", Range(1, 0)) = 0.75

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = 0.5

	// Should not be directly exposed to the user
	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5.0
	_ScaleX				("Scale X", float) = 1.0
	_ScaleY				("Scale Y", float) = 1.0
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_CullMode			("Cull Mode", Float) = 0
	//_MaskCoord		("Mask Coords", vector) = (0,0,0,0)
	//_MaskSoftness		("Mask Softness", float) = 0
}

SubShader {

	Tags {
		"Queue"="Transparent"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}

	LOD 300
	Cull [_CullMode]

	CGPROGRAM
	#pragma surface PixShader Lambert alpha:blend vertex:VertShader noforwardadd nolightmap nodirlightmap
	#pragma target 3.0
	#pragma shader_feature __ GLOW_ON

	#include "TMPro_Properties.cginc"
	#include "TMPro.cginc"

	half _FaceShininess;
	half _OutlineShininess;

	struct Input
	{
		fixed4	color		: COLOR;
		float2	uv_MainTex;
		float2	uv2_FaceTex;
		float2  uv2_OutlineTex;
		float2	param;					// Weight, Scale
		float3	viewDirEnv;
	};

	#include "TMPro_Surface.cginc"

	ENDCG

	// Pass to render object as a shadow caster
	Pass
	{
		Name "Caster"
		Tags { "LightMode" = "ShadowCaster" }
		Offset 1, 1

		Fog {Mode Off}
		ZWrite On ZTest LEqual Cull Off

		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag
		#pragma multi_compile_shadowcaster
		#include "UnityCG.cginc"

		struct v2f
		{
			V2F_SHADOW_CASTER;
			float2	uv			: TEXCOORD1;
			float2	uv2			: TEXCOORD3;
			float	alphaClip	: TEXCOORD2;
		};

		uniform float4 _MainTex_ST;
		uniform float4 _OutlineTex_ST;
		float _OutlineWidth;
		float _FaceDilate;
		float _ScaleRatioA;

		v2f vert( appdata_base v )
		{
			v2f o;
			TRANSFER_SHADOW_CASTER(o)
			o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
			o.uv2 = TRANSFORM_TEX(v.texcoord, _OutlineTex);
			o.alphaClip = o.alphaClip = (1.0 - _OutlineWidth * _ScaleRatioA - _FaceDilate * _ScaleRatioA) / 2;
			return o;
		}

		uniform sampler2D _MainTex;

		float4 frag(v2f i) : COLOR
		{
			fixed4 texcol = tex2D(_MainTex, i.uv).a;
			clip(texcol.a - i.alphaClip);
			SHADOW_CASTER_FRAGMENT(i)
		}
		ENDCG
	}
}

CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF-Surface.shader">
Shader "TextMeshPro/Distance Field (Surface)" {

Properties {
	_FaceTex			("Fill Texture", 2D) = "white" {}
	_FaceUVSpeedX		("Face UV Speed X", Range(-5, 5)) = 0.0
	_FaceUVSpeedY		("Face UV Speed Y", Range(-5, 5)) = 0.0
	_FaceColor		    ("Fill Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineTex			("Outline Texture", 2D) = "white" {}
	_OutlineUVSpeedX	("Outline UV Speed X", Range(-5, 5)) = 0.0
	_OutlineUVSpeedY	("Outline UV Speed Y", Range(-5, 5)) = 0.0
	_OutlineWidth		("Outline Thickness", Range(0, 1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_Bevel				("Bevel", Range(0,1)) = 0.5
	_BevelOffset		("Bevel Offset", Range(-0.5,0.5)) = 0
	_BevelWidth			("Bevel Width", Range(-.5,0.5)) = 0
	_BevelClamp			("Bevel Clamp", Range(0,1)) = 0
	_BevelRoundness		("Bevel Roundness", Range(0,1)) = 0

	_BumpMap 			("Normalmap", 2D) = "bump" {}
	_BumpOutline		("Bump Outline", Range(0,1)) = 0.5
	_BumpFace			("Bump Face", Range(0,1)) = 0.5

	_ReflectFaceColor	    ("Face Color", Color) = (0,0,0,1)
	_ReflectOutlineColor	("Outline Color", Color) = (0,0,0,1)
	_Cube 					("Reflection Cubemap", Cube) = "black" { /* TexGen CubeReflect */ }
	_EnvMatrixRotation  	("Texture Rotation", vector) = (0, 0, 0, 0)
	_SpecColor		        ("Specular Color", Color) = (0,0,0,1)

	_FaceShininess		("Face Shininess", Range(0,1)) = 0
	_OutlineShininess	("Outline Shininess", Range(0,1)) = 0

	_GlowColor		    ("Color", Color) = (0, 1, 0, 0.5)
	_GlowOffset			("Offset", Range(-1,1)) = 0
	_GlowInner			("Inner", Range(0,1)) = 0.05
	_GlowOuter			("Outer", Range(0,1)) = 0.05
	_GlowPower			("Falloff", Range(1, 0)) = 0.75

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = 0.5

	// Should not be directly exposed to the user
	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5.0
	_ScaleX				("Scale X", float) = 1.0
	_ScaleY				("Scale Y", float) = 1.0
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_CullMode			("Cull Mode", Float) = 0
	//_MaskCoord		("Mask Coords", vector) = (0,0,0,0)
	//_MaskSoftness		("Mask Softness", float) = 0
}

SubShader {

	Tags { "Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" }

	LOD 300
	Cull [_CullMode]

	CGPROGRAM
	#pragma surface PixShader BlinnPhong alpha:blend vertex:VertShader nolightmap nodirlightmap
	#pragma target 3.0
	#pragma shader_feature __ GLOW_ON
	#pragma glsl

	#include "TMPro_Properties.cginc"
	#include "TMPro.cginc"

	half _FaceShininess;
	half _OutlineShininess;

	struct Input
	{
		fixed4	color			: COLOR;
		float2	uv_MainTex;
		float2	uv2_FaceTex;
		float2  uv2_OutlineTex;
		float2	param;						// Weight, Scale
		float3	viewDirEnv;
	};


	#define BEVEL_ON 1
	#include "TMPro_Surface.cginc"

	ENDCG

	// Pass to render object as a shadow caster
	Pass
	{
		Name "Caster"
		Tags { "LightMode" = "ShadowCaster" }
		Offset 1, 1

		Fog {Mode Off}
		ZWrite On
		ZTest LEqual
		Cull Off

		CGPROGRAM
		#pragma vertex vert
		#pragma fragment frag
		#pragma multi_compile_shadowcaster
		#include "UnityCG.cginc"

		struct v2f
		{
			V2F_SHADOW_CASTER;
			float2	uv			: TEXCOORD1;
			float2	uv2			: TEXCOORD3;
			float	alphaClip	: TEXCOORD2;
		};

		uniform float4 _MainTex_ST;
		uniform float4 _OutlineTex_ST;
		float _OutlineWidth;
		float _FaceDilate;
		float _ScaleRatioA;

		v2f vert( appdata_base v )
		{
			v2f o;
			TRANSFER_SHADOW_CASTER(o)
			o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
			o.uv2 = TRANSFORM_TEX(v.texcoord, _OutlineTex);
			o.alphaClip = (1.0 - _OutlineWidth * _ScaleRatioA - _FaceDilate * _ScaleRatioA) / 2;
			return o;
		}

		uniform sampler2D _MainTex;

		float4 frag(v2f i) : COLOR
		{
			fixed4 texcol = tex2D(_MainTex, i.uv).a;
			clip(texcol.a - i.alphaClip);
			SHADOW_CASTER_FRAGMENT(i)
		}
		ENDCG
	}
}

CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_SDF.shader">
Shader "TextMeshPro/Distance Field" {

Properties {
	_FaceTex			("Face Texture", 2D) = "white" {}
	_FaceUVSpeedX		("Face UV Speed X", Range(-5, 5)) = 0.0
	_FaceUVSpeedY		("Face UV Speed Y", Range(-5, 5)) = 0.0
	_FaceColor		    ("Face Color", Color) = (1,1,1,1)
	_FaceDilate			("Face Dilate", Range(-1,1)) = 0

	_OutlineColor	    ("Outline Color", Color) = (0,0,0,1)
	_OutlineTex			("Outline Texture", 2D) = "white" {}
	_OutlineUVSpeedX	("Outline UV Speed X", Range(-5, 5)) = 0.0
	_OutlineUVSpeedY	("Outline UV Speed Y", Range(-5, 5)) = 0.0
	_OutlineWidth		("Outline Thickness", Range(0, 1)) = 0
	_OutlineSoftness	("Outline Softness", Range(0,1)) = 0

	_Bevel				("Bevel", Range(0,1)) = 0.5
	_BevelOffset		("Bevel Offset", Range(-0.5,0.5)) = 0
	_BevelWidth			("Bevel Width", Range(-.5,0.5)) = 0
	_BevelClamp			("Bevel Clamp", Range(0,1)) = 0
	_BevelRoundness		("Bevel Roundness", Range(0,1)) = 0

	_LightAngle			("Light Angle", Range(0.0, 6.2831853)) = 3.1416
	_SpecularColor	    ("Specular", Color) = (1,1,1,1)
	_SpecularPower		("Specular", Range(0,4)) = 2.0
	_Reflectivity		("Reflectivity", Range(5.0,15.0)) = 10
	_Diffuse			("Diffuse", Range(0,1)) = 0.5
	_Ambient			("Ambient", Range(1,0)) = 0.5

	_BumpMap 			("Normal map", 2D) = "bump" {}
	_BumpOutline		("Bump Outline", Range(0,1)) = 0
	_BumpFace			("Bump Face", Range(0,1)) = 0

	_ReflectFaceColor	("Reflection Color", Color) = (0,0,0,1)
	_ReflectOutlineColor("Reflection Color", Color) = (0,0,0,1)
	_Cube 				("Reflection Cubemap", Cube) = "black" { /* TexGen CubeReflect */ }
	_EnvMatrixRotation	("Texture Rotation", vector) = (0, 0, 0, 0)


	_UnderlayColor	    ("Border Color", Color) = (0,0,0, 0.5)
	_UnderlayOffsetX	("Border OffsetX", Range(-1,1)) = 0
	_UnderlayOffsetY	("Border OffsetY", Range(-1,1)) = 0
	_UnderlayDilate		("Border Dilate", Range(-1,1)) = 0
	_UnderlaySoftness	("Border Softness", Range(0,1)) = 0

	_GlowColor		    ("Color", Color) = (0, 1, 0, 0.5)
	_GlowOffset			("Offset", Range(-1,1)) = 0
	_GlowInner			("Inner", Range(0,1)) = 0.05
	_GlowOuter			("Outer", Range(0,1)) = 0.05
	_GlowPower			("Falloff", Range(1, 0)) = 0.75

	_WeightNormal		("Weight Normal", float) = 0
	_WeightBold			("Weight Bold", float) = 0.5

	_ShaderFlags		("Flags", float) = 0
	_ScaleRatioA		("Scale RatioA", float) = 1
	_ScaleRatioB		("Scale RatioB", float) = 1
	_ScaleRatioC		("Scale RatioC", float) = 1

	_MainTex			("Font Atlas", 2D) = "white" {}
	_TextureWidth		("Texture Width", float) = 512
	_TextureHeight		("Texture Height", float) = 512
	_GradientScale		("Gradient Scale", float) = 5.0
	_ScaleX				("Scale X", float) = 1.0
	_ScaleY				("Scale Y", float) = 1.0
	_PerspectiveFilter	("Perspective Correction", Range(0, 1)) = 0.875
	_Sharpness			("Sharpness", Range(-1,1)) = 0

	_VertexOffsetX		("Vertex OffsetX", float) = 0
	_VertexOffsetY		("Vertex OffsetY", float) = 0

	_MaskCoord			("Mask Coordinates", vector) = (0, 0, 32767, 32767)
	_ClipRect			("Clip Rect", vector) = (-32767, -32767, 32767, 32767)
	_MaskSoftnessX		("Mask SoftnessX", float) = 0
	_MaskSoftnessY		("Mask SoftnessY", float) = 0

	_StencilComp		("Stencil Comparison", Float) = 8
	_Stencil			("Stencil ID", Float) = 0
	_StencilOp			("Stencil Operation", Float) = 0
	_StencilWriteMask	("Stencil Write Mask", Float) = 255
	_StencilReadMask	("Stencil Read Mask", Float) = 255

	_CullMode			("Cull Mode", Float) = 0
	_ColorMask			("Color Mask", Float) = 15
}

SubShader {

	Tags
	{
		"Queue"="Transparent"
		"IgnoreProjector"="True"
		"RenderType"="Transparent"
	}

	Stencil
	{
		Ref [_Stencil]
		Comp [_StencilComp]
		Pass [_StencilOp]
		ReadMask [_StencilReadMask]
		WriteMask [_StencilWriteMask]
	}

	Cull [_CullMode]
	ZWrite Off
	Lighting Off
	Fog { Mode Off }
	ZTest [unity_GUIZTestMode]
	Blend One OneMinusSrcAlpha
	ColorMask [_ColorMask]

	Pass {
		CGPROGRAM
		#pragma target 3.0
		#pragma vertex VertShader
		#pragma fragment PixShader
		#pragma shader_feature __ BEVEL_ON
		#pragma shader_feature __ UNDERLAY_ON UNDERLAY_INNER
		#pragma shader_feature __ GLOW_ON

		#pragma multi_compile __ UNITY_UI_CLIP_RECT
		#pragma multi_compile __ UNITY_UI_ALPHACLIP

		#include "UnityCG.cginc"
		#include "UnityUI.cginc"
		#include "TMPro_Properties.cginc"
		#include "TMPro.cginc"

		struct vertex_t
		{
			UNITY_VERTEX_INPUT_INSTANCE_ID
			float4	position		: POSITION;
			float3	normal			: NORMAL;
			fixed4	color			: COLOR;
			float4	texcoord0		: TEXCOORD0;
			float2	texcoord1		: TEXCOORD1;
		};

		struct pixel_t
		{
			UNITY_VERTEX_INPUT_INSTANCE_ID
			UNITY_VERTEX_OUTPUT_STEREO
			float4	position		: SV_POSITION;
			fixed4	color			: COLOR;
			float2	atlas			: TEXCOORD0;		// Atlas
			float4	param			: TEXCOORD1;		// alphaClip, scale, bias, weight
			float4	mask			: TEXCOORD2;		// Position in object space(xy), pixel Size(zw)
			float3	viewDir			: TEXCOORD3;

		    #if (UNDERLAY_ON || UNDERLAY_INNER)
			float4	texcoord2		: TEXCOORD4;		// u,v, scale, bias
			fixed4	underlayColor	: COLOR1;
		    #endif

		    float4 textures			: TEXCOORD5;
		};

		// Used by Unity internally to handle Texture Tiling and Offset.
		float4 _FaceTex_ST;
		float4 _OutlineTex_ST;
		float _UIMaskSoftnessX;
        float _UIMaskSoftnessY;
        int _UIVertexColorAlwaysGammaSpace;

		pixel_t VertShader(vertex_t input)
		{
			pixel_t output;

			UNITY_INITIALIZE_OUTPUT(pixel_t, output);
			UNITY_SETUP_INSTANCE_ID(input);
			UNITY_TRANSFER_INSTANCE_ID(input,output);
			UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(output);

			float bold = step(input.texcoord0.w, 0);

			float4 vert = input.position;
			vert.x += _VertexOffsetX;
			vert.y += _VertexOffsetY;

			float4 vPosition = UnityObjectToClipPos(vert);

			float2 pixelSize = vPosition.w;
			pixelSize /= float2(_ScaleX, _ScaleY) * abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));
			float scale = rsqrt(dot(pixelSize, pixelSize));
			scale *= abs(input.texcoord0.w) * _GradientScale * (_Sharpness + 1);
			if (UNITY_MATRIX_P[3][3] == 0) scale = lerp(abs(scale) * (1 - _PerspectiveFilter), scale, abs(dot(UnityObjectToWorldNormal(input.normal.xyz), normalize(WorldSpaceViewDir(vert)))));

			float weight = lerp(_WeightNormal, _WeightBold, bold) / 4.0;
			weight = (weight + _FaceDilate) * _ScaleRatioA * 0.5;

			float bias =(.5 - weight) + (.5 / scale);

			float alphaClip = (1.0 - _OutlineWidth * _ScaleRatioA - _OutlineSoftness * _ScaleRatioA);

		    #if GLOW_ON
			alphaClip = min(alphaClip, 1.0 - _GlowOffset * _ScaleRatioB - _GlowOuter * _ScaleRatioB);
		    #endif

			alphaClip = alphaClip / 2.0 - ( .5 / scale) - weight;

		    #if (UNDERLAY_ON || UNDERLAY_INNER)
			float4 underlayColor = _UnderlayColor;
			underlayColor.rgb *= underlayColor.a;

			float bScale = scale;
			bScale /= 1 + ((_UnderlaySoftness*_ScaleRatioC) * bScale);
			float bBias = (0.5 - weight) * bScale - 0.5 - ((_UnderlayDilate * _ScaleRatioC) * 0.5 * bScale);

			float x = -(_UnderlayOffsetX * _ScaleRatioC) * _GradientScale / _TextureWidth;
			float y = -(_UnderlayOffsetY * _ScaleRatioC) * _GradientScale / _TextureHeight;
			float2 bOffset = float2(x, y);
		    #endif

			// Generate UV for the Masking Texture
			float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
			float2 maskUV = (vert.xy - clampedRect.xy) / (clampedRect.zw - clampedRect.xy);

			// Support for texture tiling and offset
			float2 textureUV = input.texcoord1;
			float2 faceUV = TRANSFORM_TEX(textureUV, _FaceTex);
			float2 outlineUV = TRANSFORM_TEX(textureUV, _OutlineTex);


            if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
            {
                input.color.rgb = UIGammaToLinear(input.color.rgb);
            }
			output.position = vPosition;
			output.color = input.color;
			output.atlas =	input.texcoord0;
			output.param =	float4(alphaClip, scale, bias, weight);
			const half2 maskSoftness = half2(max(_UIMaskSoftnessX, _MaskSoftnessX), max(_UIMaskSoftnessY, _MaskSoftnessY));
			output.mask = half4(vert.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * maskSoftness + pixelSize.xy));
			output.viewDir =	mul((float3x3)_EnvMatrix, _WorldSpaceCameraPos.xyz - mul(unity_ObjectToWorld, vert).xyz);
			#if (UNDERLAY_ON || UNDERLAY_INNER)
			output.texcoord2 = float4(input.texcoord0 + bOffset, bScale, bBias);
			output.underlayColor =	underlayColor;
			#endif
			output.textures = float4(faceUV, outlineUV);

			return output;
		}


		fixed4 PixShader(pixel_t input) : SV_Target
		{
			UNITY_SETUP_INSTANCE_ID(input);

			float c = tex2D(_MainTex, input.atlas).a;

		    #ifndef UNDERLAY_ON
			clip(c - input.param.x);
		    #endif

			float	scale	= input.param.y;
			float	bias	= input.param.z;
			float	weight	= input.param.w;
			float	sd = (bias - c) * scale;

			float outline = (_OutlineWidth * _ScaleRatioA) * scale;
			float softness = (_OutlineSoftness * _ScaleRatioA) * scale;

			half4 faceColor = _FaceColor;
			half4 outlineColor = _OutlineColor;

			faceColor.rgb *= input.color.rgb;

			faceColor *= tex2D(_FaceTex, input.textures.xy + float2(_FaceUVSpeedX, _FaceUVSpeedY) * _Time.y);
			outlineColor *= tex2D(_OutlineTex, input.textures.zw + float2(_OutlineUVSpeedX, _OutlineUVSpeedY) * _Time.y);

			faceColor = GetColor(sd, faceColor, outlineColor, outline, softness);

		    #if BEVEL_ON
			float3 dxy = float3(0.5 / _TextureWidth, 0.5 / _TextureHeight, 0);
			float3 n = GetSurfaceNormal(input.atlas, weight, dxy);

			float3 bump = UnpackNormal(tex2D(_BumpMap, input.textures.xy + float2(_FaceUVSpeedX, _FaceUVSpeedY) * _Time.y)).xyz;
			bump *= lerp(_BumpFace, _BumpOutline, saturate(sd + outline * 0.5));
			n = normalize(n- bump);

			float3 light = normalize(float3(sin(_LightAngle), cos(_LightAngle), -1.0));

			float3 col = GetSpecular(n, light);
			faceColor.rgb += col*faceColor.a;
			faceColor.rgb *= 1-(dot(n, light)*_Diffuse);
			faceColor.rgb *= lerp(_Ambient, 1, n.z*n.z);

			fixed4 reflcol = texCUBE(_Cube, reflect(input.viewDir, -n));
			faceColor.rgb += reflcol.rgb * lerp(_ReflectFaceColor.rgb, _ReflectOutlineColor.rgb, saturate(sd + outline * 0.5)) * faceColor.a;
		    #endif

		    #if UNDERLAY_ON
			float d = tex2D(_MainTex, input.texcoord2.xy).a * input.texcoord2.z;
			faceColor += input.underlayColor * saturate(d - input.texcoord2.w) * (1 - faceColor.a);
		    #endif

		    #if UNDERLAY_INNER
			float d = tex2D(_MainTex, input.texcoord2.xy).a * input.texcoord2.z;
			faceColor += input.underlayColor * (1 - saturate(d - input.texcoord2.w)) * saturate(1 - sd) * (1 - faceColor.a);
		    #endif

		    #if GLOW_ON
			float4 glowColor = GetGlowColor(sd, scale);
			faceColor.rgb += glowColor.rgb * glowColor.a;
		    #endif

		// Alternative implementation to UnityGet2DClipping with support for softness.
		    #if UNITY_UI_CLIP_RECT
			half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(input.mask.xy)) * input.mask.zw);
			faceColor *= m.x * m.y;
		    #endif

		    #if UNITY_UI_ALPHACLIP
			clip(faceColor.a - 0.001);
		    #endif

  		    return faceColor * input.color.a;
		}
		ENDCG
	}
}

Fallback "TextMeshPro/Mobile/Distance Field"
CustomEditor "TMPro.EditorUtilities.TMP_SDFShaderGUI"
}
</file>

<file path="Assets/TextMesh Pro/Shaders/TMP_Sprite.shader">
Shader "TextMeshPro/Sprite"
{
	Properties
	{
        _MainTex            ("Sprite Texture", 2D) = "white" {}
		_Color              ("Tint", Color) = (1,1,1,1)

		_StencilComp        ("Stencil Comparison", Float) = 8
		_Stencil            ("Stencil ID", Float) = 0
		_StencilOp          ("Stencil Operation", Float) = 0
		_StencilWriteMask   ("Stencil Write Mask", Float) = 255
		_StencilReadMask    ("Stencil Read Mask", Float) = 255

		_CullMode           ("Cull Mode", Float) = 0
		_ColorMask          ("Color Mask", Float) = 15
		_ClipRect           ("Clip Rect", vector) = (-32767, -32767, 32767, 32767)

		[Toggle(UNITY_UI_ALPHACLIP)] _UseUIAlphaClip ("Use Alpha Clip", Float) = 0
	}

	SubShader
	{
		Tags
		{
			"Queue"="Transparent"
			"IgnoreProjector"="True"
			"RenderType"="Transparent"
			"PreviewType"="Plane"
			"CanUseSpriteAtlas"="True"
		}

		Stencil
		{
			Ref [_Stencil]
			Comp [_StencilComp]
			Pass [_StencilOp]
			ReadMask [_StencilReadMask]
			WriteMask [_StencilWriteMask]
		}

		Cull [_CullMode]
		Lighting Off
		ZWrite Off
		ZTest [unity_GUIZTestMode]
		Blend SrcAlpha OneMinusSrcAlpha
		ColorMask [_ColorMask]

		Pass
		{
            Name "Default"
		CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
            #pragma target 2.0

			#include "UnityCG.cginc"
			#include "UnityUI.cginc"

            #pragma multi_compile __ UNITY_UI_CLIP_RECT
            #pragma multi_compile __ UNITY_UI_ALPHACLIP

			struct appdata_t
			{
				float4 vertex   : POSITION;
				float4 color    : COLOR;
				float2 texcoord : TEXCOORD0;
                UNITY_VERTEX_INPUT_INSTANCE_ID
			};

			struct v2f
			{
				float4 vertex			: SV_POSITION;
				fixed4 color			: COLOR;
                float2 texcoord			: TEXCOORD0;
				float4 worldPosition	: TEXCOORD1;
				float4 mask				: TEXCOORD2;
                UNITY_VERTEX_OUTPUT_STEREO
			};

            sampler2D _MainTex;
			fixed4 _Color;
			fixed4 _TextureSampleAdd;
			float4 _ClipRect;
            float4 _MainTex_ST;
		    float _UIMaskSoftnessX;
            float _UIMaskSoftnessY;
            int _UIVertexColorAlwaysGammaSpace;

            v2f vert(appdata_t v)
			{
				v2f OUT;
                UNITY_SETUP_INSTANCE_ID(v);
                UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(OUT);
				float4 vPosition = UnityObjectToClipPos(v.vertex);
            	OUT.worldPosition = v.vertex;
				OUT.vertex = vPosition;

            	float2 pixelSize = vPosition.w;
                pixelSize /= abs(mul((float2x2)UNITY_MATRIX_P, _ScreenParams.xy));

				float4 clampedRect = clamp(_ClipRect, -2e10, 2e10);
                OUT.texcoord = TRANSFORM_TEX(v.texcoord, _MainTex);
                OUT.mask = half4(v.vertex.xy * 2 - clampedRect.xy - clampedRect.zw, 0.25 / (0.25 * half2(_UIMaskSoftnessX, _UIMaskSoftnessY) + abs(pixelSize.xy)));

                if (_UIVertexColorAlwaysGammaSpace && !IsGammaSpace())
                {
                    v.color.rgb = UIGammaToLinear(v.color.rgb);
                }
                OUT.color = v.color * _Color;
				return OUT;
			}

			fixed4 frag(v2f IN) : SV_Target
			{
				half4 color = (tex2D(_MainTex, IN.texcoord) + _TextureSampleAdd) * IN.color;

                #if UNITY_UI_CLIP_RECT
				half2 m = saturate((_ClipRect.zw - _ClipRect.xy - abs(IN.mask.xy)) * IN.mask.zw);
				color *= m.x * m.y;
				#endif

				#ifdef UNITY_UI_ALPHACLIP
					clip (color.a - 0.001);
				#endif

				return color;
			}
		    ENDCG
		}
	}
}
</file>

<file path="Assets/TutorialInfo/Scripts/Editor/ReadmeEditor.cs">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System;
using System.IO;
using System.Reflection;

[CustomEditor(typeof(Readme))]
[InitializeOnLoad]
public class ReadmeEditor : Editor
{
    static string s_ShowedReadmeSessionStateName = "ReadmeEditor.showedReadme";
    
    static string s_ReadmeSourceDirectory = "Assets/TutorialInfo";

    const float k_Space = 16f;

    static ReadmeEditor()
    {
        EditorApplication.delayCall += SelectReadmeAutomatically;
    }

    static void RemoveTutorial()
    {
        if (EditorUtility.DisplayDialog("Remove Readme Assets",
            
            $"All contents under {s_ReadmeSourceDirectory} will be removed, are you sure you want to proceed?",
            "Proceed",
            "Cancel"))
        {
            if (Directory.Exists(s_ReadmeSourceDirectory))
            {
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory);
                FileUtil.DeleteFileOrDirectory(s_ReadmeSourceDirectory + ".meta");
            }
            else
            {
                Debug.Log($"Could not find the Readme folder at {s_ReadmeSourceDirectory}");
            }

            var readmeAsset = SelectReadme();
            if (readmeAsset != null)
            {
                var path = AssetDatabase.GetAssetPath(readmeAsset);
                FileUtil.DeleteFileOrDirectory(path + ".meta");
                FileUtil.DeleteFileOrDirectory(path);
            }

            AssetDatabase.Refresh();
        }
    }

    static void SelectReadmeAutomatically()
    {
        if (!SessionState.GetBool(s_ShowedReadmeSessionStateName, false))
        {
            var readme = SelectReadme();
            SessionState.SetBool(s_ShowedReadmeSessionStateName, true);

            if (readme && !readme.loadedLayout)
            {
                LoadLayout();
                readme.loadedLayout = true;
            }
        }
    }

    static void LoadLayout()
    {
        var assembly = typeof(EditorApplication).Assembly;
        var windowLayoutType = assembly.GetType("UnityEditor.WindowLayout", true);
        var method = windowLayoutType.GetMethod("LoadWindowLayout", BindingFlags.Public | BindingFlags.Static);
        method.Invoke(null, new object[] { Path.Combine(Application.dataPath, "TutorialInfo/Layout.wlt"), false });
    }

    static Readme SelectReadme()
    {
        var ids = AssetDatabase.FindAssets("Readme t:Readme");
        if (ids.Length == 1)
        {
            var readmeObject = AssetDatabase.LoadMainAssetAtPath(AssetDatabase.GUIDToAssetPath(ids[0]));

            Selection.objects = new UnityEngine.Object[] { readmeObject };

            return (Readme)readmeObject;
        }
        else
        {
            Debug.Log("Couldn't find a readme");
            return null;
        }
    }

    protected override void OnHeaderGUI()
    {
        var readme = (Readme)target;
        Init();

        var iconWidth = Mathf.Min(EditorGUIUtility.currentViewWidth / 3f - 20f, 128f);

        GUILayout.BeginHorizontal("In BigTitle");
        {
            if (readme.icon != null)
            {
                GUILayout.Space(k_Space);
                GUILayout.Label(readme.icon, GUILayout.Width(iconWidth), GUILayout.Height(iconWidth));
            }
            GUILayout.Space(k_Space);
            GUILayout.BeginVertical();
            {

                GUILayout.FlexibleSpace();
                GUILayout.Label(readme.title, TitleStyle);
                GUILayout.FlexibleSpace();
            }
            GUILayout.EndVertical();
            GUILayout.FlexibleSpace();
        }
        GUILayout.EndHorizontal();
    }

    public override void OnInspectorGUI()
    {
        var readme = (Readme)target;
        Init();

        foreach (var section in readme.sections)
        {
            if (!string.IsNullOrEmpty(section.heading))
            {
                GUILayout.Label(section.heading, HeadingStyle);
            }

            if (!string.IsNullOrEmpty(section.text))
            {
                GUILayout.Label(section.text, BodyStyle);
            }

            if (!string.IsNullOrEmpty(section.linkText))
            {
                if (LinkLabel(new GUIContent(section.linkText)))
                {
                    Application.OpenURL(section.url);
                }
            }

            GUILayout.Space(k_Space);
        }

        if (GUILayout.Button("Remove Readme Assets", ButtonStyle))
        {
            RemoveTutorial();
        }
    }

    bool m_Initialized;

    GUIStyle LinkStyle
    {
        get { return m_LinkStyle; }
    }

    [SerializeField]
    GUIStyle m_LinkStyle;

    GUIStyle TitleStyle
    {
        get { return m_TitleStyle; }
    }

    [SerializeField]
    GUIStyle m_TitleStyle;

    GUIStyle HeadingStyle
    {
        get { return m_HeadingStyle; }
    }

    [SerializeField]
    GUIStyle m_HeadingStyle;

    GUIStyle BodyStyle
    {
        get { return m_BodyStyle; }
    }

    [SerializeField]
    GUIStyle m_BodyStyle;

    GUIStyle ButtonStyle
    {
        get { return m_ButtonStyle; }
    }

    [SerializeField]
    GUIStyle m_ButtonStyle;

    void Init()
    {
        if (m_Initialized)
            return;
        m_BodyStyle = new GUIStyle(EditorStyles.label);
        m_BodyStyle.wordWrap = true;
        m_BodyStyle.fontSize = 14;
        m_BodyStyle.richText = true;

        m_TitleStyle = new GUIStyle(m_BodyStyle);
        m_TitleStyle.fontSize = 26;

        m_HeadingStyle = new GUIStyle(m_BodyStyle);
        m_HeadingStyle.fontStyle = FontStyle.Bold;
        m_HeadingStyle.fontSize = 18;

        m_LinkStyle = new GUIStyle(m_BodyStyle);
        m_LinkStyle.wordWrap = false;

        // Match selection color which works nicely for both light and dark skins
        m_LinkStyle.normal.textColor = new Color(0x00 / 255f, 0x78 / 255f, 0xDA / 255f, 1f);
        m_LinkStyle.stretchWidth = false;

        m_ButtonStyle = new GUIStyle(EditorStyles.miniButton);
        m_ButtonStyle.fontStyle = FontStyle.Bold;

        m_Initialized = true;
    }

    bool LinkLabel(GUIContent label, params GUILayoutOption[] options)
    {
        var position = GUILayoutUtility.GetRect(label, LinkStyle, options);

        Handles.BeginGUI();
        Handles.color = LinkStyle.normal.textColor;
        Handles.DrawLine(new Vector3(position.xMin, position.yMax), new Vector3(position.xMax, position.yMax));
        Handles.color = Color.white;
        Handles.EndGUI();

        EditorGUIUtility.AddCursorRect(position, MouseCursor.Link);

        return GUI.Button(position, label, LinkStyle);
    }
}
</file>

<file path="Assets/TutorialInfo/Scripts/Readme.cs">
using System;
using UnityEngine;

public class Readme : ScriptableObject
{
    public Texture2D icon;
    public string title;
    public Section[] sections;
    public bool loadedLayout;

    [Serializable]
    public class Section
    {
        public string heading, text, linkText, url;
    }
}
</file>

</files>
